# Анализ архитектуры backend state для горизонтального масштабирования

## Обзор задачи

Необходимо вынести состояние backend приложения в отдельный контейнер для обеспечения горизонтального масштабирования и развертывания дополнительных backend инстансов при повышении нагрузки.

## Анализ существующих кешей в backend приложении

### Критические кеши (требуют выноса в state-контейнер)

1. **Settings Cache** - ВЫСОКИЙ ПРИОРИТЕТ
   - Содержит настройки JWT, безопасности, конфигурации приложения
   - Используется во всех модулях для получения критических настроек
   - При масштабировании каждый инстанс должен иметь идентичные настройки
   - Текущая реализация: in-memory объект

2. **Users List Cache** - ВЫСОКИЙ ПРИОРИТЕТ
   - Кеширует результаты поиска/фильтрации пользователей с параметризованными ключами
   - При масштабировании разные инстансы могут показывать неконсистентные данные
   - Текущая реализация: Map с TTL (30 мин) и LRU политикой (600 записей)

3. **Helper Cache** - СРЕДНИЙ ПРИОРИТЕТ
   - Кеширует UUID групп, имена пользователей, статусы, проверки админ-прав
   - Используется для авторизации и валидации запросов
   - При масштабировании может привести к неконсистентности авторизации
   - Текущая реализация: Map с TTL по типам (5-30 мин, 1000-5000 записей)

### Не критичные кеши (можно оставить in-memory)

4. **Validation Cache** - НИЗКИЙ ПРИОРИТЕТ
   - Кеширует скомпилированные правила валидации
   - Статичные данные, не изменяются во время работы

5. **Security Validation Cache** - НИЗКИЙ ПРИОРИТЕТ
   - Кеширует паттерны безопасности
   - Статичные данные, аналогично validation cache

6. **Event Bus Templates Cache** - СРЕДНИЙ ПРИОРИТЕТ
   - Кеширует шаблоны событий
   - При масштабировании все инстансы должны использовать одинаковые шаблоны

7. **Token Management** - УЖЕ РЕШЕНО
   - Refresh tokens хранятся в PostgreSQL
   - Настройки токенов берутся из Settings Cache

## Рассмотренные технологии

### 1. Redis

**Преимущества:**
- Высокая производительность (in-memory)
- Встроенная поддержка TTL из коробки
- Pub/Sub для уведомлений об изменениях
- Кластеризация и репликация
- Богатый набор структур данных
- Широкое распространение и отличная экосистема

**Критические недостатки:**
- **Геополитические риски** - Redis Inc. может вводить ограничения для отдельных стран
- **Изменения лицензий** - переход на проприетарные лицензии RSALv2, SSPLv1, AGPL в 2024 году
- **Единый правообладатель** - зависимость от одной компании
- **Прецеденты** - множество западных IT-компаний включая Redis приостановили деятельность в России в 2022 году

### 2. Tarantool DB

**Преимущества:**
- Российская разработка - включена в Реестр отечественного ПО
- Сертификация ФСТЭК
- Высокая производительность - in-memory с персистентностью
- ACID транзакции
- SQL поддержка

**Недостатки:**
- **Over-engineering** - полноценная база данных для простого кеширования
- Высокая сложность настройки и управления
- Избыточная функциональность для задач кеширования

### 3. Apache Ignite

**Преимущества:**
- In-memory computing platform
- SQL поддержка
- ACID транзакции

**Недостатки:**
- Более сложная настройка
- Больше потребление ресурсов
- Менее популярен чем Redis

### 4. Собственная реализация

**Преимущества:**
- Полный контроль над логикой
- Нет внешних зависимостей
- Можно оптимизировать под конкретные нужды

**Недостатки:**
- Высокие затраты на разработку и поддержку
- Необходимость реализации всех функций (TTL, кластеризация, персистентность)
- Сложность тестирования и отладки
- Риск багов в критической инфраструктуре

### 5. Memcached

**Преимущества:**
- **Создан именно для кеширования** - не база данных
- **Простой протокол** - get/set/delete с TTL
- **Минимальные ресурсы** - легкий контейнер
- **Проверенная технология** - используется десятилетиями
- **Низкие геополитические риски** - BSD лицензия, развитие сообществом
- **Высокая производительность** - оптимизирован для кеширования

**Недостатки:**
- Ограниченная функциональность - только кеширование
- Нет персистентности - данные теряются при перезапуске

## Факторы выбора Memcached

### 1. Геополитическая безопасность

**Memcached:**
- ✅ **Низкий риск** - BSD лицензия не дает правообладателю контроля над использованием
- ✅ **Сообщество** - развитие контролируется сообществом, а не одной компанией
- ✅ **Открытый исходный код** - можно форкнуть и поддерживать независимо
- ✅ **Linux Foundation** - поддержка крупной международной организации

**Redis:**
- ❌ **Высокий риск** - компания Redis Inc. может вводить ограничения
- ❌ **Проприетарные лицензии** - дают больше контроля правообладателю
- ❌ **Единый правообладатель** - зависимость от одной компании

### 2. Производительность

**Сравнение быстродействия:**
- **In-memory cache:** ~1-10 наносекунд (прямой доступ к памяти)
- **Memcached (локальная сеть):** ~0.1-1 миллисекунда
- **Собственная реализация (HTTP):** ~0.1-1 миллисекунда

**Memcached быстрее собственной реализации в 3-10 раз** за счет:
- Бинарного протокола vs HTTP
- Нативной сериализации vs JSON
- Оптимизированных алгоритмов vs самописных
- Специализированных структур данных

### 3. Сложность реализации

**Memcached:**
- **Время интеграции:** 2-3 дня
- **Строки кода:** 100-300 строк
- **Компоненты:** 1-2 модуля
- **Тестирование:** Только интеграционные тесты

**Собственная разработка:**
- **Время разработки:** 2-4 недели
- **Строки кода:** 1000-3000 строк
- **Компоненты:** 5-10 модулей
- **Тестирование:** Unit + Integration + Load tests

**Memcached проще в 10-15 раз.**

### 4. Операционная поддержка

**Memcached:**
- **Мониторинг:** Готовые инструменты (Prometheus, Grafana)
- **Отладка:** Стандартные процедуры
- **Обновления:** Автоматические через пакетные менеджеры
- **Масштабирование:** Встроенные механизмы
- **Документация:** Обширная и актуальная

**Собственная разработка:**
- **Мониторинг:** Кастомные метрики и алерты
- **Отладка:** Анализ собственного кода
- **Обновления:** Разработка и тестирование патчей
- **Масштабирование:** Кастомная логика балансировки
- **Документация:** Создание с нуля

**Memcached требует в 5-10 раз меньше операционных усилий.**

## Выбранная конфигурация Memcached

### Базовый образ
- **Официальный образ:** `memcached:1.6-alpine`
- **Размер образа:** ~5-10 МБ (Alpine Linux)
- **Основа:** Linux Alpine (минимальная дистрибуция)

### Ресурсные требования

**Память (RAM):**
- **Выделенная память для кеша:** 128 МБ
- **Системная память:** 128 МБ
- **Общее потребление:** 256 МБ

**CPU:**
- **В покое:** 0.1-0.5% от одного ядра
- **При активной работе:** 1-5% от одного ядра
- **Пиковая нагрузка:** 5-15% от одного ядра

**Диск:**
- **Размер контейнера:** ~10-20 МБ
- **Логи:** 1-10 МБ в день
- **Общее потребление:** ~20-50 МБ

### Конфигурация безопасности

**Сетевая изоляция:**
- **Приватная Docker сеть** - изоляция от внешнего мира
- **Ограничение доступа** - только backend контейнеры могут подключаться
- **Firewall правила** - блокировка внешних подключений

**Параметры Memcached:**
- **`-m 128`** - выделить 128 МБ для кеша
- **`-I 1m`** - максимальный размер элемента 1 МБ
- **`-c 100`** - максимум 100 одновременных соединений
- **`-t 2`** - использовать 2 потока
- **`-l 172.20.0.0/16`** - слушать только в приватной сети

**Безопасность контейнера:**
- **Non-root пользователь** - запуск от пользователя memcache
- **Read-write файловая система** - для логирования и временных файлов
- **Ограниченные capabilities** - минимальные права

### Мониторинг

**Ключевые метрики:**
- **Hit ratio** - процент попаданий в кеш
- **Operations per second** - количество операций
- **Response time** - время отклика
- **Memory usage** - использование памяти

**Инструменты:**
- **Health checks** - проверка доступности
- **Docker logs** - логирование в stdout
- **Stats команда** - базовая статистика

## План миграции

1. **Этап 1**: Установка и настройка Memcached контейнера
2. **Этап 2**: Создание клиентских библиотек для интеграции
3. **Этап 3**: Миграция Settings Cache (критично)
4. **Этап 4**: Миграция Users List Cache
5. **Этап 5**: Миграция Helper Cache
6. **Этап 6**: Тестирование и оптимизация

## Итоговые рекомендации

**Memcached является оптимальным выбором** для решения задачи выноса состояния backend приложения:

1. **Безопасность** - низкие геополитические риски
2. **Производительность** - в 3-10 раз быстрее собственной реализации
3. **Простота** - в 10-15 раз проще в реализации
4. **Поддержка** - в 5-10 раз меньше операционных усилий
5. **Адекватность** - создан именно для кеширования, не over-engineering

Выбранная конфигурация обеспечивает оптимальный баланс между безопасностью, производительностью и простотой управления для потребностей в кешировании при горизонтальном масштабировании backend приложения.