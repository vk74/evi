#!/usr/bin/env bash
#
# Version: 1.7.5
# Purpose: evi production deployment controller (rootless Podman + Quadlet).
# Deployment file: evictl
# Logic:
# - Provides CLI subcommands (up/down/restart/status/logs/health/cert/env-info/info/backup/restore)
# - Provides interactive menu mode when run without args
# - Shows container status table on menu entry
# - Renders Quadlet units from templates, renders Caddyfile, and manages secrets
# - Supports full backup and restore of EVI environment
#
# Changes in v1.7.5:
# - pgAdmin: default login evidba@pgadmin.app (EVI_PGADMIN_EMAIL_DEFAULT); override via evi.env; help text shows fixed login
#
# Changes in v1.7.4:
# - Menu banner shows script version (parsed from header)
#
# Changes in v1.7.3:
# - pgAdmin: default EVI_PGADMIN_HOST=0.0.0.0 for browser access from any computer (port 5445)
#
# Changes in v1.7.2:
# - Menu: exit option moved to digit 0, displayed first (after status table)
#
# Changes in v1.7.1:
# - Backup location: option 1 = evi/backup, option 2 = custom path, 3+ = detected mount points
# - get_mount_points accepts optional start_index; numbering is continuous (no gap)
# - Distro archive and UI use evi (evi-v*.tar.gz, evi repo)
#
# Changes in v1.7.0:
# - Added backup command with interactive directory selection and compression options
# - Added restore command placeholder (calls backup-restore.sh)
# - Added backup-info command to display backup contents
# - Updated menu with backup & restore section
# - Backup includes: container images, database, env files, TLS certs, JWT secrets, pgAdmin data
# - Backup creates self-contained archive with evi repo for offline restore
#
# Changes in v1.6.0:
# - Refactored admin menu: removed init, build, update, cleanup, doctor commands
# - Added container status table displayed on menu entry
# - Grouped container management operations with clear English names
# - Separated logs into individual commands for each container
# - Added environment info command (includes certificate info)
# - Added cockpit & pgadmin help command
# - Added menu frame header like install.sh
# - Logs commands now show copyable command string
#
# Changes in v1.5.5:
# - Fixed frontend-backend connection in production: added --build-arg VUE_APP_API_URL=/api to frontend build
# - Frontend now uses relative path /api for API calls (works with Caddy reverse proxy)
#
# Changes in v1.5.4:
# - Fixed pgAdmin permission error: set ownership of data directory to UID 5050
# - Used podman unshare chown for rootless Podman compatibility
#
# Changes in v1.5.3:
# - Fixed pgAdmin not starting: added load_env_files() call to cmd_up()
# - Added pgAdmin support to cmd_down(), cmd_restart(), cmd_status()
# - Added EVI_PGADMIN_EMAIL to template rendering keys
# - Added pgadmin/data directory creation for persistent storage
#
# Changes in v1.5.2:
# - Fixed unbound variable error for EVI_PGADMIN_ENABLED
# - Added default values for all EVI_PGADMIN_* variables in load_env_files
#
# Changes in v1.5.1:
# - Updated pgAdmin rendering: removed auth credentials, added localhost-only binding
# - Added servers.json rendering for pre-configured evi-db connection in pgAdmin
# - Added EVI_ADMIN_DB_USERNAME, EVI_PGADMIN_HOST, EVI_PGADMIN_PORT to template rendering
#
# Changes in v1.5.0:
# - Added cleanup command to remove source code files after successful deployment
# - Cleanup prompt appears automatically after successful evictl up (interactive mode)
# - Cleanup verifies deployment is running before removing files
# - Cleanup removes: back/, front/, db/, docs/, README.md, package.json, package-lock.json, .git/
#
# Changes in v1.4.0:
# - Added health command for comprehensive service health checks
# - Added cert command with subcommands: info, check, regen, install
# - Lowercase styling for menu and messages
#
# Changes in v1.3.0:
# - Fixed TLS handshake error by using port-based Caddy binding instead of domain-based
# - Added auto_https off for manual TLS mode
# - Refactored Caddyfile rendering with EVI_CADDY_GLOBAL_OPTIONS and EVI_HTTP_REDIRECT_BLOCK
# - Removed internal TLS mode (simplified to manual and letsencrypt only)
#
# Changes in v1.2.1:
# - Fixed unbound variable error: EVI_TLS_CERT_IN_CONTAINER now set in render_caddyfile()
#
# Changes in v1.2.0:
# - Updated manual TLS mode to auto-detect certificates from deployment/env/tls/
# - Removed internal TLS mode recommendation in favor of manual mode with self-signed certs
# - Improved certificate path resolution (supports absolute and relative paths)
#
# Changes in v1.1.4:
# - Updated internal TLS configuration to use sign_with_root option
# - This fixes TLS handshake errors caused by intermediate CA chain issues
#
# Changes in v1.1.3:
# - Fixed EVI_CADDY_EMAIL_BLOCK placeholder not being processed in render_template_file
# - Simplified internal TLS configuration to avoid syntax errors
#
# Changes in v1.1.2:
# - Fixed internal TLS mode for IP addresses: disabled global email to prevent automatic ACME attempts
# - Updated Caddyfile.site.internal.template to use explicit issuer configuration
# - Added sign_with_root option for better certificate compatibility
#
# Changes in v1.1.1:
# - Added internal TLS mode support (Caddy local CA).
# - Added strict validation for EVI_TLS_MODE and EVI_DOMAIN.
# - Updated doctor check for unprivileged port start.
#
# Changes in v1.1.0:
# - Added 'build' command to build images from source using tags from env file.
#
# Changes in v1.0.0:
# - Initial CLI + menu tool for prod deployment using Caddy reverse-proxy on 80/443
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOYMENT_DIR="${SCRIPT_DIR}"
ENV_DIR="${DEPLOYMENT_DIR}/env"
TPL_DIR="${DEPLOYMENT_DIR}/quadlet-templates"
PROXY_DIR="${DEPLOYMENT_DIR}/reverse-proxy"
SCRIPTS_DIR="${DEPLOYMENT_DIR}/scripts"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

EVI_STATE_DIR_DEFAULT="${HOME}/.local/share/evi"
EVI_CONFIG_DIR_DEFAULT="${HOME}/.config/evi"
EVI_QUADLET_DIR_DEFAULT="${HOME}/.config/containers/systemd"

EVI_ENV_FILE_DEFAULT="${ENV_DIR}/evi.env"
EVI_SECRETS_FILE_DEFAULT="${ENV_DIR}/evi.secrets.env"

# pgAdmin web-console login username (hardcoded default; override via EVI_PGADMIN_EMAIL in evi.env)
EVI_PGADMIN_EMAIL_DEFAULT="evidba@pgadmin.app"

EVICTL_VERSION=$(sed -n '1,20p' "${SCRIPT_DIR}/$(basename "${BASH_SOURCE[0]:-$0}")" 2>/dev/null | grep -m1 '^# Version: ' | sed 's/^# Version:[[:space:]]*//' || echo "?")

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Status symbols
SYM_OK="${GREEN}[✓]${NC}"
SYM_FAIL="${RED}[✗]${NC}"
SYM_WARN="${YELLOW}[!]${NC}"
SYM_PENDING="${GRAY}[○]${NC}"

log() { printf "%s\n" "$*"; }
warn() { printf "WARN: %s\n" "$*" >&2; }
die() { printf "ERROR: %s\n" "$*" >&2; exit 1; }

require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

load_env_files() {
  # shellcheck disable=SC1090
  if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]]; then 
    source "${EVI_ENV_FILE_DEFAULT}"
  else 
    # Fallback to template ONLY if main env is missing? 
    # No, for prod we should fail or warn heavily.
    # But for fresh install, init might need to read something.
    # However, init usually happens AFTER config wizard.
    die "Missing config file: ${EVI_ENV_FILE_DEFAULT}. Run install.sh or configure first."
  fi
  
  # shellcheck disable=SC1090
  if [[ -f "${EVI_SECRETS_FILE_DEFAULT}" ]]; then 
    source "${EVI_SECRETS_FILE_DEFAULT}"
  else 
    die "Missing secrets file: ${EVI_SECRETS_FILE_DEFAULT}. Run install.sh or configure first."
  fi

  export EVI_STATE_DIR="${EVI_STATE_DIR:-${EVI_STATE_DIR_DEFAULT}}"
  export EVI_CONFIG_DIR="${EVI_CONFIG_DIR:-${EVI_CONFIG_DIR_DEFAULT}}"
  export EVI_QUADLET_DIR="${EVI_QUADLET_DIR:-${EVI_QUADLET_DIR_DEFAULT}}"

  export EVI_JWT_SECRET_NAME="${EVI_JWT_SECRET_NAME:-evi_jwt_private_key}"
  
  # Default admin username if not set
  export EVI_ADMIN_DB_USERNAME="${EVI_ADMIN_DB_USERNAME:-evidba}"
  
  # Default pgAdmin settings (disabled by default)
  export EVI_PGADMIN_ENABLED="${EVI_PGADMIN_ENABLED:-false}"
  export EVI_PGADMIN_IMAGE="${EVI_PGADMIN_IMAGE:-docker.io/dpage/pgadmin4:8}"
  export EVI_PGADMIN_HOST="${EVI_PGADMIN_HOST:-0.0.0.0}"
  export EVI_PGADMIN_PORT="${EVI_PGADMIN_PORT:-5445}"
  export EVI_PGADMIN_EMAIL="${EVI_PGADMIN_EMAIL:-${EVI_PGADMIN_EMAIL_DEFAULT}}"

  # Validation
  [[ -n "${EVI_DOMAIN:-}" ]] || die "EVI_DOMAIN is not set in evi.env"
  
  EVI_TLS_MODE="${EVI_TLS_MODE:-letsencrypt}"
  if [[ "${EVI_TLS_MODE}" != "letsencrypt" && "${EVI_TLS_MODE}" != "manual" ]]; then
    die "Invalid EVI_TLS_MODE: '${EVI_TLS_MODE}'. Must be one of: letsencrypt, manual."
  fi
}

ensure_dirs() {
  mkdir -p "${EVI_STATE_DIR}/reverse-proxy" "${EVI_STATE_DIR}/tls" "${EVI_STATE_DIR}/secrets"
  mkdir -p "${EVI_STATE_DIR}/pgadmin" "${EVI_STATE_DIR}/pgadmin/data"
  mkdir -p "${EVI_CONFIG_DIR}"
  mkdir -p "${EVI_QUADLET_DIR}"
  
  # pgAdmin runs as UID 5050 inside the container.
  # For rootless Podman, we need to map this UID to host using podman unshare.
  if [[ -d "${EVI_STATE_DIR}/pgadmin/data" ]]; then
    # Use podman unshare to set ownership within user namespace
    podman unshare chown 5050:5050 "${EVI_STATE_DIR}/pgadmin/data" 2>/dev/null || true
  fi
}

render_template_file() {
  local in_file="$1"
  local out_file="$2"
  shift 2

  local content
  content="$(cat "${in_file}")"

  # Replace {{KEY}} placeholders based on exported env vars.
  # Note: Keep this simple and deterministic for MVP.
  local keys=(
    EVI_DOMAIN EVI_ACME_EMAIL EVI_TLS_MODE
    EVI_HTTP_PORT EVI_HTTPS_PORT
    EVI_PROXY_IMAGE EVI_FE_IMAGE EVI_BE_IMAGE EVI_DB_IMAGE
    EVI_NETWORK EVI_BE_PORT EVI_FE_PORT EVI_DB_PORT
    EVI_NODE_ENV EVI_CORS_ORIGINS
    EVI_POSTGRES_DB EVI_POSTGRES_USER EVI_POSTGRES_PASSWORD EVI_APP_DB_PASSWORD EVI_ADMIN_DB_USERNAME EVI_ADMIN_DB_PASSWORD EVI_SEED_DEMO_DATA
    EVI_STATE_DIR EVI_JWT_SECRET_NAME
    EVI_PGADMIN_IMAGE EVI_PGADMIN_HOST EVI_PGADMIN_PORT EVI_PGADMIN_EMAIL
  )

  local k v
  for k in "${keys[@]}"; do
    v="${!k-}"
    content="${content//\{\{${k}\}\}/${v}}"
  done

  # Render dynamic blocks prepared by caller (placeholders remain if unset)
  content="${content//\{\{EVI_PODMANARGS_LIMITS_PROXY\}\}/${EVI_PODMANARGS_LIMITS_PROXY-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_FE\}\}/${EVI_PODMANARGS_LIMITS_FE-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_BE\}\}/${EVI_PODMANARGS_LIMITS_BE-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_DB\}\}/${EVI_PODMANARGS_LIMITS_DB-}}"
  content="${content//\{\{EVI_PROXY_TLS_MOUNTS\}\}/${EVI_PROXY_TLS_MOUNTS-}}"
  content="${content//\{\{EVI_TLS_SITE_BLOCK\}\}/${EVI_TLS_SITE_BLOCK-}}"
  content="${content//\{\{EVI_CADDY_EMAIL_BLOCK\}\}/${EVI_CADDY_EMAIL_BLOCK-}}"
  content="${content//\{\{EVI_CADDY_GLOBAL_OPTIONS\}\}/${EVI_CADDY_GLOBAL_OPTIONS-}}"
  content="${content//\{\{EVI_HTTP_REDIRECT_BLOCK\}\}/${EVI_HTTP_REDIRECT_BLOCK-}}"

  printf "%s\n" "${content}" > "${out_file}"
}

compute_limits_block() {
  # Build PodmanArgs lines for limits (CPU/memory) based on env.
  # We keep them empty if unset.
  local cpu="$1"
  local mem="$2"
  local out=""

  if [[ -n "${cpu}" ]]; then
    out+=$'PodmanArgs=--cpus='"${cpu}"$'\n'
  fi
  if [[ -n "${mem}" ]]; then
    out+=$'PodmanArgs=--memory='"${mem}"$'\n'
  fi

  printf "%s" "${out}"
}

prepare_proxy_tls_mounts() {
  # For manual TLS, we mount cert/key from state dir into container.
  if [[ "${EVI_TLS_MODE}" == "manual" ]]; then
    export EVI_TLS_CERT_IN_CONTAINER="/etc/evi-tls/cert.pem"
    export EVI_TLS_KEY_IN_CONTAINER="/etc/evi-tls/key.pem"
    export EVI_PROXY_TLS_MOUNTS=$'Volume='"${EVI_STATE_DIR}"$'/tls/cert.pem:'"${EVI_TLS_CERT_IN_CONTAINER}"$':ro,Z\nVolume='"${EVI_STATE_DIR}"$'/tls/key.pem:'"${EVI_TLS_KEY_IN_CONTAINER}"$':ro,Z\n'
  else
    export EVI_PROXY_TLS_MOUNTS=""
  fi
}

render_caddyfile() {
  local base_tpl="${PROXY_DIR}/Caddyfile.template"
  local site_tpl=""

  # Build global options based on TLS mode
  if [[ "${EVI_TLS_MODE}" == "manual" ]]; then
    # Manual TLS requires auto_https off to prevent Caddy from interfering
    export EVI_CADDY_GLOBAL_OPTIONS="auto_https off"
    # HTTP redirect uses port-based binding for manual mode
    export EVI_HTTP_REDIRECT_BLOCK=":${EVI_HTTP_PORT} {
	redir https://${EVI_DOMAIN}{uri} permanent
}"
    # Set container paths for manual TLS mode (fixed paths inside container)
    export EVI_TLS_CERT_IN_CONTAINER="/etc/evi-tls/cert.pem"
    export EVI_TLS_KEY_IN_CONTAINER="/etc/evi-tls/key.pem"
    
    site_tpl="${PROXY_DIR}/Caddyfile.site.manual.template"
    export EVI_TLS_SITE_BLOCK="$(cat "${site_tpl}")"
    export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_TLS_CERT_IN_CONTAINER\}\}/${EVI_TLS_CERT_IN_CONTAINER}}"
    export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_TLS_KEY_IN_CONTAINER\}\}/${EVI_TLS_KEY_IN_CONTAINER}}"
  else
    # Let's Encrypt mode - need email for ACME
    export EVI_CADDY_GLOBAL_OPTIONS="email ${EVI_ACME_EMAIL:-admin@example.com}"
    export EVI_HTTP_REDIRECT_BLOCK="http://${EVI_DOMAIN}:${EVI_HTTP_PORT} {
	redir https://${EVI_DOMAIN}{uri} permanent
}"
    site_tpl="${PROXY_DIR}/Caddyfile.site.letsencrypt.template"
    export EVI_TLS_SITE_BLOCK="$(cat "${site_tpl}")"
  fi

  # Replace the common placeholders inside the site block
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_DOMAIN\}\}/${EVI_DOMAIN}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_HTTP_PORT\}\}/${EVI_HTTP_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_HTTPS_PORT\}\}/${EVI_HTTPS_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_BE_PORT\}\}/${EVI_BE_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_FE_PORT\}\}/${EVI_FE_PORT}}"

  render_template_file "${base_tpl}" "${EVI_STATE_DIR}/reverse-proxy/Caddyfile"
  log "OK: rendered Caddyfile to ${EVI_STATE_DIR}/reverse-proxy/Caddyfile"
}

create_or_update_secret_from_file() {
  local secret_name="$1"
  local file_path="$2"

  [[ -f "${file_path}" ]] || die "Secret source file not found: ${file_path}"

  if podman secret inspect "${secret_name}" >/dev/null 2>&1; then
    podman secret rm "${secret_name}" >/dev/null
  fi
  podman secret create "${secret_name}" "${file_path}" >/dev/null
}

prepare_jwt_secret() {
  require_cmd podman

  local target="${EVI_STATE_DIR}/secrets/jwt_private_key.pem"

  if [[ "${EVI_JWT_GENERATE_KEY}" == "true" ]]; then
    log "Generating new JWT key pair..."
    require_cmd openssl
    # Ensure script is executable
    chmod +x "${SCRIPTS_DIR}/gen-jwt-rs256-keypair.sh"
    "${SCRIPTS_DIR}/gen-jwt-rs256-keypair.sh" "${EVI_STATE_DIR}/secrets" "jwt_private_key.pem" >/dev/null
    log "OK: JWT key pair generated."
  elif [[ -n "${EVI_JWT_PRIVATE_KEY_PEM_PATH}" ]]; then
    log "Using provided JWT key from file..."
    cp -f "${EVI_JWT_PRIVATE_KEY_PEM_PATH}" "${target}"
    chmod 600 "${target}"
  elif [[ -n "${EVI_JWT_PRIVATE_KEY_PEM_INLINE}" ]]; then
    log "Using provided JWT key from inline config..."
    printf "%s\n" "${EVI_JWT_PRIVATE_KEY_PEM_INLINE}" > "${target}"
    chmod 600 "${target}"
  else
    die "JWT key not provided. Set EVI_JWT_GENERATE_KEY=true or provide EVI_JWT_PRIVATE_KEY_PEM_PATH or EVI_JWT_PRIVATE_KEY_PEM_INLINE."
  fi

  create_or_update_secret_from_file "${EVI_JWT_SECRET_NAME}" "${target}"
  log "OK: created/updated podman secret ${EVI_JWT_SECRET_NAME}"
}

resolve_tls_path() {
  # Resolve TLS file path - supports absolute and relative paths
  local path="$1"
  
  if [[ -z "${path}" ]]; then
    echo ""
    return
  fi
  
  # If absolute path, use as-is
  if [[ "${path}" == /* ]]; then
    echo "${path}"
    return
  fi
  
  # Try relative to ENV_DIR first
  if [[ -f "${ENV_DIR}/${path}" ]]; then
    echo "${ENV_DIR}/${path}"
    return
  fi
  
  # Try relative to DEPLOYMENT_DIR
  if [[ -f "${DEPLOYMENT_DIR}/${path}" ]]; then
    echo "${DEPLOYMENT_DIR}/${path}"
    return
  fi
  
  # Return original (let caller handle error)
  echo "${path}"
}

prepare_manual_tls_files() {
  if [[ "${EVI_TLS_MODE}" != "manual" ]]; then
    return 0
  fi

  local cert_path="${EVI_TLS_CERT_PATH:-}"
  local key_path="${EVI_TLS_KEY_PATH:-}"
  
  # Auto-detect from default TLS directory if not specified
  local default_tls_dir="${ENV_DIR}/tls"
  
  if [[ -z "${cert_path}" && -f "${default_tls_dir}/cert.pem" ]]; then
    cert_path="${default_tls_dir}/cert.pem"
    log "Auto-detected certificate: ${cert_path}"
  fi
  
  if [[ -z "${key_path}" && -f "${default_tls_dir}/key.pem" ]]; then
    key_path="${default_tls_dir}/key.pem"
    log "Auto-detected private key: ${key_path}"
  fi
  
  # Resolve paths (handle relative paths)
  cert_path=$(resolve_tls_path "${cert_path}")
  key_path=$(resolve_tls_path "${key_path}")

  if [[ -n "${cert_path}" && -n "${key_path}" ]]; then
    if [[ ! -f "${cert_path}" ]]; then
      die "TLS certificate not found: ${cert_path}"
    fi
    if [[ ! -f "${key_path}" ]]; then
      die "TLS private key not found: ${key_path}"
    fi
    
    log "Importing manual TLS certificates..."
    chmod +x "${SCRIPTS_DIR}/import-tls.sh"
    "${SCRIPTS_DIR}/import-tls.sh" "${cert_path}" "${key_path}" "${EVI_STATE_DIR}/tls" >/dev/null
    log "OK: imported manual TLS cert/key to ${EVI_STATE_DIR}/tls"
    return 0
  fi

  die "Manual TLS selected but certificates not found. Either:
  1. Generate certificates using install.sh -> TLS Certificates menu
  2. Set EVI_TLS_CERT_PATH and EVI_TLS_KEY_PATH in evi.secrets.env
  3. Place cert.pem and key.pem in ${default_tls_dir}/"
}

render_quadlets() {
  # Compute optional limits
  export EVI_PODMANARGS_LIMITS_PROXY
  export EVI_PODMANARGS_LIMITS_FE
  export EVI_PODMANARGS_LIMITS_BE
  export EVI_PODMANARGS_LIMITS_DB

  EVI_PODMANARGS_LIMITS_PROXY="$(compute_limits_block "${EVI_LIMIT_CPU_PROXY-}" "${EVI_LIMIT_MEM_PROXY-}")"
  EVI_PODMANARGS_LIMITS_FE="$(compute_limits_block "${EVI_LIMIT_CPU_FE-}" "${EVI_LIMIT_MEM_FE-}")"
  EVI_PODMANARGS_LIMITS_BE="$(compute_limits_block "${EVI_LIMIT_CPU_BE-}" "${EVI_LIMIT_MEM_BE-}")"
  EVI_PODMANARGS_LIMITS_DB="$(compute_limits_block "${EVI_LIMIT_CPU_DB-}" "${EVI_LIMIT_MEM_DB-}")"

  prepare_proxy_tls_mounts

  render_template_file "${TPL_DIR}/evi.network" "${EVI_QUADLET_DIR}/evi.network"
  render_template_file "${TPL_DIR}/evi-db.volume" "${EVI_QUADLET_DIR}/evi-db.volume"

  render_template_file "${TPL_DIR}/evi-db.container" "${EVI_QUADLET_DIR}/evi-db.container"
  render_template_file "${TPL_DIR}/evi-be.container" "${EVI_QUADLET_DIR}/evi-be.container"
  render_template_file "${TPL_DIR}/evi-fe.container" "${EVI_QUADLET_DIR}/evi-fe.container"
  render_template_file "${TPL_DIR}/evi-reverse-proxy.container" "${EVI_QUADLET_DIR}/evi-reverse-proxy.container"

  # Optional pgAdmin
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    # Render pgAdmin container quadlet
    render_template_file "${TPL_DIR}/evi-pgadmin.container" "${EVI_QUADLET_DIR}/evi-pgadmin.container"
    
    # Render servers.json for pre-configured evi-db connection
    local pgadmin_tpl="${DEPLOYMENT_DIR}/pgadmin/servers.json.template"
    local pgadmin_out="${EVI_STATE_DIR}/pgadmin/servers.json"
    if [[ -f "${pgadmin_tpl}" ]]; then
      local servers_content
      servers_content="$(cat "${pgadmin_tpl}")"
      servers_content="${servers_content//\{\{EVI_ADMIN_DB_USERNAME\}\}/${EVI_ADMIN_DB_USERNAME:-evidba}}"
      printf "%s\n" "${servers_content}" > "${pgadmin_out}"
      log "OK: rendered pgAdmin servers.json"
    else
      warn "pgAdmin servers.json template not found at ${pgadmin_tpl}"
    fi
  else
    # Remove if disabled/exists
    if [[ -f "${EVI_QUADLET_DIR}/evi-pgadmin.container" ]]; then
      rm "${EVI_QUADLET_DIR}/evi-pgadmin.container"
    fi
  fi

  log "OK: rendered Quadlet files into ${EVI_QUADLET_DIR}"
}

systemd_user_daemon_reload() {
  systemctl --user daemon-reload
}


cmd_up() {
  require_cmd systemctl
  require_cmd podman
  load_env_files
  
  # Pull images so they are present before starting units (visible in log; surfaces GHCR auth errors)
  log "Pulling container images..."
  podman pull "${EVI_PROXY_IMAGE}" || { err "Failed to pull ${EVI_PROXY_IMAGE}"; return 1; }
  podman pull "${EVI_DB_IMAGE}"   || { err "Failed to pull ${EVI_DB_IMAGE}"; return 1; }
  podman pull "${EVI_BE_IMAGE}"   || { err "Failed to pull ${EVI_BE_IMAGE}"; return 1; }
  podman pull "${EVI_FE_IMAGE}"   || { err "Failed to pull ${EVI_FE_IMAGE}"; return 1; }
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    podman pull "${EVI_PGADMIN_IMAGE:-docker.io/dpage/pgadmin4:8}" || { err "Failed to pull pgAdmin image"; return 1; }
  fi
  log "OK: images pulled."

  # Reload systemd units in case they were changed
  systemctl --user daemon-reload

  systemctl --user start evi-network.service evi-db-volume.service || true
  # Explicitly start services (autostart is handled by [Install] via generator)
  systemctl --user start evi-db evi-be evi-fe evi-reverse-proxy

  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    if ! systemctl --user start evi-pgadmin; then
      warn "Failed to start evi-pgadmin service. Check logs with: journalctl --user -u evi-pgadmin"
      return 1
    fi
    # Give it a moment to start and check if it's running
    sleep 2
    if ! systemctl --user is-active --quiet evi-pgadmin; then
      warn "evi-pgadmin service started but is not active. Check logs with: journalctl --user -u evi-pgadmin"
    fi
  fi
  
  log "OK: started services."
}

cmd_down() {
  require_cmd systemctl
  load_env_files
  
  # Stop pgAdmin first if enabled
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    systemctl --user stop evi-pgadmin || true
  fi
  
  systemctl --user stop evi-reverse-proxy evi-fe evi-be evi-db || true
  log "OK: stopped services."
}

cmd_restart() {
  require_cmd systemctl
  load_env_files
  
  systemctl --user restart evi-db evi-be evi-fe evi-reverse-proxy
  
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    systemctl --user restart evi-pgadmin
  fi
  
  log "OK: restarted services."
}

cmd_status() {
  require_cmd systemctl
  load_env_files
  
  local services="evi-reverse-proxy evi-fe evi-be evi-db"
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    services="${services} evi-pgadmin"
  fi
  
  systemctl --user status ${services} --no-pager || true
}

# --- Container Status Functions ---

get_project_containers() {
  local containers=("evi-db" "evi-be" "evi-fe" "evi-reverse-proxy")
  
  # Check if pgAdmin is enabled
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    containers+=("evi-pgadmin")
  fi
  
  printf "%s\n" "${containers[@]}"
}

get_container_status() {
  local container_name="$1"
  local state
  
  # Use inspect for authoritative status
  if ! state=$(podman inspect --format "{{.State.Status}}" "${container_name}" 2>/dev/null); then
    echo "not_found"
    return
  fi
  
  if [[ "${state}" == "running" ]]; then
    # Check if restarting
    if podman inspect --format "{{.State.Restarting}}" "${container_name}" 2>/dev/null | grep -q "true"; then
      echo "restarting"
    else
      echo "running"
    fi
  elif [[ "${state}" == "created" ]] || [[ "${state}" == "initialized" ]]; then
    echo "starting"
  else
    echo "stopped"
  fi
}

get_container_health() {
  local container_name="$1"
  local health
  health=$(podman inspect --format "{{.State.Health.Status}}" "${container_name}" 2>/dev/null || echo "none")
  
  if [[ -z "${health}" ]] || [[ "${health}" == "<no value>" ]]; then
    echo "none"
  else
    echo "${health}"
  fi
}

get_container_uptime() {
  local container_name="$1"
  local uptime
  uptime=$(podman inspect --format "{{.State.StartedAt}}" "${container_name}" 2>/dev/null || echo "")
  
  if [[ -z "${uptime}" ]] || [[ "${uptime}" == "<no value>" ]]; then
    echo ""
    return
  fi
  
  # Calculate uptime from started time
  local started_epoch
  started_epoch=$(date -d "${uptime}" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "${uptime}" +%s 2>/dev/null || echo "0")
  local now_epoch
  now_epoch=$(date +%s)
  
  if [[ "${started_epoch}" == "0" ]] || [[ "${started_epoch}" -eq 0 ]]; then
    echo ""
    return
  fi
  
  local diff=$((now_epoch - started_epoch))
  local minutes=$((diff / 60))
  local hours=$((minutes / 60))
  local days=$((hours / 24))
  
  if [[ ${days} -gt 0 ]]; then
    echo "${days}d ${hours}h"
  elif [[ ${hours} -gt 0 ]]; then
    echo "${hours}h ${minutes}m"
  else
    echo "${minutes}m"
  fi
}

get_container_ports() {
  local container_name="$1"
  podman ps --filter "name=^${container_name}$" --format "{{.Ports}}" 2>/dev/null | head -1 || echo ""
}

display_container_status_table() {
  require_cmd podman
  
  # Try to load env files, but don't fail if they don't exist
  if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]] && [[ -f "${EVI_SECRETS_FILE_DEFAULT}" ]]; then
    # shellcheck disable=SC1090
    source "${EVI_ENV_FILE_DEFAULT}" 2>/dev/null || true
    # shellcheck disable=SC1090
    source "${EVI_SECRETS_FILE_DEFAULT}" 2>/dev/null || true
    export EVI_PGADMIN_ENABLED="${EVI_PGADMIN_ENABLED:-false}"
  else
    export EVI_PGADMIN_ENABLED="false"
  fi
  
  echo ""
  printf "  ${CYAN}container status:${NC}\n"
  
  local containers
  containers=$(get_project_containers)
  
  while IFS= read -r container; do
    [[ -z "${container}" ]] && continue
    
    local status
    status=$(get_container_status "${container}")
    local health
    health=$(get_container_health "${container}")
    local uptime
    uptime=$(get_container_uptime "${container}")
    local ports
    ports=$(get_container_ports "${container}")
    
    # Status display
    case "${status}" in
      running)
        printf "    ${SYM_OK} ${GREEN}%-15s${NC}" "${container}:"
        ;;
      restarting|starting)
        printf "    ${SYM_WARN} ${YELLOW}%-15s${NC}" "${container}:"
        ;;
      stopped|not_found)
        printf "    ${SYM_FAIL} ${RED}%-15s${NC}" "${container}:"
        ;;
      *)
        printf "    ${SYM_PENDING} %-15s" "${container}:"
        ;;
    esac
    
    # Status text
    case "${status}" in
      running)
        printf " ${GREEN}running${NC}"
        ;;
      restarting)
        printf " ${YELLOW}restarting${NC}"
        ;;
      starting)
        printf " ${YELLOW}starting${NC}"
        ;;
      stopped)
        printf " ${RED}stopped${NC}"
        ;;
      not_found)
        printf " ${RED}not found${NC}"
        ;;
      *)
        printf " ${GRAY}unknown${NC}"
        ;;
    esac
    
    # Health status
    if [[ "${status}" == "running" ]]; then
      case "${health}" in
        healthy)
          printf " ${GREEN}(healthy)${NC}"
          ;;
        unhealthy)
          printf " ${YELLOW}(unhealthy)${NC}"
          ;;
        starting)
          printf " ${YELLOW}(healthcheck starting)${NC}"
          ;;
        *)
          printf " ${GRAY}(no healthcheck)${NC}"
          ;;
      esac
      
      # Uptime
      if [[ -n "${uptime}" ]]; then
        printf " uptime: ${CYAN}%s${NC}" "${uptime}"
      fi
      
      # Ports
      if [[ -n "${ports}" ]]; then
        printf " ports: ${CYAN}%s${NC}" "${ports}"
      fi
    fi
    
    echo ""
  done <<< "${containers}"
  
  echo ""
}

cmd_logs() {
  require_cmd journalctl
  local unit="${1:-evi-reverse-proxy}"
  
  echo ""
  printf "command: ${CYAN}journalctl --user -u %s -n 200 --no-pager${NC}\n" "${unit}"
  echo ""
  
  journalctl --user -u "${unit}" -n 200 --no-pager || true
}


cmd_self_update() {
  die "self-update not implemented yet (MVP placeholder)."
}

cmd_health() {
  require_cmd podman
  load_env_files
  
  log "== health check =="
  echo ""
  
  local all_ok=true
  
  # Check containers
  log "containers:"
  local containers=("evi-db" "evi-be" "evi-fe" "evi-reverse-proxy")
  for c in "${containers[@]}"; do
    local status
    status=$(podman ps --filter "name=^${c}$" --format "{{.Status}}" 2>/dev/null || echo "")
    if [[ -n "${status}" ]]; then
      printf "  %-12s ${GREEN}running${NC} (%s)\n" "${c}:" "${status}"
    else
      printf "  %-12s ${RED}not running${NC}\n" "${c}:"
      all_ok=false
    fi
  done
  echo ""
  
  # Check database connectivity using app_service account
  log "database:"
  if podman ps --filter "name=^evi-db$" --format "{{.Status}}" 2>/dev/null | grep -q "healthy"; then
    printf "  %-12s ${GREEN}healthy${NC}\n" "status:"
    
    # Try to connect with app_service
    local db_test
    db_test=$(podman exec evi-db psql -U app_service -d maindb -c "SELECT 1;" 2>&1 || echo "FAIL")
    if echo "${db_test}" | grep -q "1 row"; then
      printf "  %-12s ${GREEN}ok${NC}\n" "app_service:"
    else
      printf "  %-12s ${YELLOW}connection issue${NC}\n" "app_service:"
    fi
  else
    printf "  %-12s ${RED}not healthy${NC}\n" "status:"
    all_ok=false
  fi
  echo ""
  
  # Check HTTPS endpoint
  log "https endpoint:"
  if require_cmd curl; then
    local https_test
    https_test=$(curl -sk --connect-timeout 5 -o /dev/null -w "%{http_code}" "https://${EVI_DOMAIN}/" 2>/dev/null || echo "000")
    if [[ "${https_test}" == "200" ]] || [[ "${https_test}" == "301" ]] || [[ "${https_test}" == "302" ]]; then
      printf "  %-12s ${GREEN}ok (HTTP ${https_test})${NC}\n" "status:"
    else
      printf "  %-12s ${YELLOW}issue (HTTP ${https_test})${NC}\n" "status:"
    fi
  else
    printf "  %-12s ${YELLOW}curl not available${NC}\n" "status:"
  fi
  echo ""
  
  # Check TLS certificate
  log "tls certificate:"
  local tls_dir="${ENV_DIR}/tls"
  if [[ "${EVI_TLS_MODE}" == "manual" ]] && [[ -f "${tls_dir}/cert.pem" ]]; then
    local expiry
    expiry=$(openssl x509 -enddate -noout -in "${tls_dir}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "")
    if [[ -n "${expiry}" ]]; then
      local expiry_epoch now_epoch days_left
      expiry_epoch=$(date -d "${expiry}" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "${expiry}" +%s 2>/dev/null || echo "0")
      now_epoch=$(date +%s)
      days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
      
      if [[ ${days_left} -lt 0 ]]; then
        printf "  %-12s ${RED}expired${NC}\n" "status:"
        all_ok=false
      elif [[ ${days_left} -lt 30 ]]; then
        printf "  %-12s ${YELLOW}expiring in ${days_left} days${NC}\n" "status:"
      else
        printf "  %-12s ${GREEN}valid (${days_left} days left)${NC}\n" "status:"
      fi
    fi
  elif [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
    printf "  %-12s ${GREEN}managed by let's encrypt${NC}\n" "mode:"
  else
    printf "  %-12s ${YELLOW}not configured${NC}\n" "status:"
  fi
  echo ""
  
  if [[ "${all_ok}" == true ]]; then
    log "overall: ${GREEN}all systems operational${NC}"
  else
    log "overall: ${YELLOW}some issues detected${NC}"
  fi
}

cmd_env_info() {
  load_env_files
  
  log "== environment information =="
  echo ""
  
  printf "  %-20s ${GREEN}%s${NC}\n" "domain:" "${EVI_DOMAIN}"
  printf "  %-20s ${GREEN}%s${NC}\n" "tls mode:" "${EVI_TLS_MODE}"
  printf "  %-20s ${GREEN}%s${NC}\n" "http port:" "${EVI_HTTP_PORT}"
  printf "  %-20s ${GREEN}%s${NC}\n" "https port:" "${EVI_HTTPS_PORT}"
  printf "  %-20s ${GREEN}%s${NC}\n" "database:" "${EVI_POSTGRES_DB}"
  printf "  %-20s ${GREEN}%s${NC}\n" "pgadmin enabled:" "${EVI_PGADMIN_ENABLED:-false}"
  
  # Certificate info if manual TLS
  if [[ "${EVI_TLS_MODE}" == "manual" ]]; then
    echo ""
    log "== certificate information =="
    local tls_dir="${ENV_DIR}/tls"
    if [[ -f "${tls_dir}/cert.pem" ]]; then
      echo ""
      openssl x509 -in "${tls_dir}/cert.pem" -noout -subject -issuer -dates -ext subjectAltName 2>/dev/null || true
      echo ""
    else
      warn "no manual certificates found in ${tls_dir}/"
    fi
  elif [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
    echo ""
    log "certificates are managed by caddy and stored in the container volume."
  fi
}

cmd_info() {
  load_env_files
  
  log "== cockpit & pgadmin help =="
  echo ""
  
  log "cockpit:"
  printf "  web-based tool for server management\n"
  printf "  url: ${GREEN}https://localhost:9090${NC}\n"
  printf "  usage: manage containers through web interface\n"
  printf "  login: use your linux system user credentials (username and password)\n"
  printf "  note: EVI_ADMIN_DB_PASSWORD can be found in cockpit -> podman containers -> integration tab (this is database password, not cockpit login password)\n"
  echo ""
  
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    log "pgadmin:"
    printf "  web console for database administration\n"
    printf "  url: ${GREEN}http://<server-ip>:${EVI_PGADMIN_PORT}${NC} (from any computer)\n"
    printf "  login: ${GREEN}evidba@pgadmin.app${NC}\n"
    printf "  password: ${GREEN}EVI_ADMIN_DB_PASSWORD${NC}\n"
    printf "  note: evi-pgadmin and evi-db are different containers, but can use same password\n"
  else
    log "pgadmin:"
    printf "  ${GRAY}not enabled${NC}\n"
  fi
}

cmd_cert() {
  local subcmd="${1:-info}"
  shift || true
  
  load_env_files
  local tls_dir="${ENV_DIR}/tls"
  
  case "${subcmd}" in
    info)
      log "== certificate information =="
      if [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
        log "mode: let's encrypt (automatic)"
        log "certificates are managed by caddy and stored in the container volume."
        return 0
      fi
      
      if [[ ! -f "${tls_dir}/cert.pem" ]]; then
        warn "no manual certificates found in ${tls_dir}/"
        return 1
      fi
      
      echo ""
      openssl x509 -in "${tls_dir}/cert.pem" -noout -subject -issuer -dates -ext subjectAltName 2>/dev/null || true
      echo ""
      ;;
    check)
      log "== certificate expiry check =="
      if [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
        log "mode: let's encrypt - certificates auto-renew"
        return 0
      fi
      
      if [[ ! -f "${tls_dir}/cert.pem" ]]; then
        warn "no certificates found"
        return 1
      fi
      
      local expiry
      expiry=$(openssl x509 -enddate -noout -in "${tls_dir}/cert.pem" 2>/dev/null | cut -d= -f2)
      local expiry_epoch now_epoch days_left
      expiry_epoch=$(date -d "${expiry}" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "${expiry}" +%s 2>/dev/null)
      now_epoch=$(date +%s)
      days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
      
      log "expires: ${expiry}"
      log "days left: ${days_left}"
      
      if [[ ${days_left} -lt 30 ]]; then
        warn "certificate expires soon - consider regenerating"
      fi
      ;;
    regen)
      log "== regenerate certificates =="
      if [[ "${EVI_TLS_MODE}" != "manual" ]]; then
        warn "regeneration only applies to manual TLS mode"
        return 1
      fi
      
      require_cmd openssl
      chmod +x "${SCRIPTS_DIR}/gen-self-signed-tls.sh"
      
      log "regenerating certificates for ${EVI_DOMAIN}..."
      "${SCRIPTS_DIR}/gen-self-signed-tls.sh" "${EVI_DOMAIN}" "${tls_dir}" --force
      
      log "certificates regenerated. restart proxy to apply:"
      log "  systemctl --user restart evi-reverse-proxy"
      ;;
    install)
      log "== client certificate installation ==="
      if [[ ! -f "${tls_dir}/evi-tls.crt" ]]; then
        warn "CA certificate not found. Generate certificates first."
        return 1
      fi
      
      echo ""
      echo "to eliminate browser warnings, install the CA certificate:"
      echo ""
      echo "certificate file: ${tls_dir}/evi-tls.crt"
      echo ""
      echo "windows: double-click > install > local machine > trusted root ca"
      echo "macos:   double-click > add to keychain > set 'always trust'"
      echo "linux:   sudo cp evi-tls.crt /usr/local/share/ca-certificates/ && sudo update-ca-certificates"
      echo "firefox: settings > privacy > certificates > import > trust for websites"
      echo ""
      ;;
    *)
      echo "usage: evictl cert <info|check|regen|install>"
      ;;
  esac
}


# --- Backup & Restore Functions ---

# Get list of mount points with available space.
# Optional first argument: start_index (default 1) for option numbering.
get_mount_points() {
  local start_index="${1:-1}"
  local evi_disk
  evi_disk=$(df "${EVI_STATE_DIR:-${HOME}/.local/share/evi}" 2>/dev/null | tail -1 | awk '{print $1}' || echo "")
  
  local i=0
  while read -r target avail source; do
    ((i++))
    local note=""
    if [[ "${source}" == "${evi_disk}" ]]; then
      note=" (contains evi-db)"
    fi
    printf "  %d) %-20s - %s free%s\n" "$((start_index + i - 1))" "${target}" "${avail}" "${note}"
  done < <(df -h --output=target,avail,source 2>/dev/null | tail -n +2 | \
    grep -v "^/snap\|^/boot\|^/dev\|^/run\|^/sys\|tmpfs\|devtmpfs")
}

# Get mount point by index
get_mount_point_by_index() {
  local idx="$1"
  df -h --output=target 2>/dev/null | tail -n +2 | \
    grep -v "^/snap\|^/boot\|^/dev\|^/run\|^/sys\|tmpfs\|devtmpfs" | \
    sed -n "${idx}p" | tr -d ' '
}

# Format bytes to human readable
format_bytes() {
  local bytes="$1"
  if [[ ${bytes} -ge 1073741824 ]]; then
    echo "$(echo "scale=1; ${bytes}/1073741824" | bc 2>/dev/null || echo "?") GB"
  elif [[ ${bytes} -ge 1048576 ]]; then
    echo "$(echo "scale=1; ${bytes}/1048576" | bc 2>/dev/null || echo "?") MB"
  elif [[ ${bytes} -ge 1024 ]]; then
    echo "$(echo "scale=1; ${bytes}/1024" | bc 2>/dev/null || echo "?") KB"
  else
    echo "${bytes} B"
  fi
}

# Format seconds to human readable time
format_time() {
  local seconds="$1"
  local minutes=$((seconds / 60))
  local remaining_seconds=$((seconds % 60))
  
  if [[ ${minutes} -gt 0 ]]; then
    echo "~${minutes} min"
  else
    echo "~${seconds} sec"
  fi
}

cmd_backup() {
  require_cmd podman
  
  # Try to load env files
  if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]] && [[ -f "${EVI_SECRETS_FILE_DEFAULT}" ]]; then
    load_env_files
  else
    die "EVI environment not configured. Run install.sh first."
  fi
  
  # Get EVI version from image tag
  local evi_version
  evi_version=$(echo "${EVI_FE_IMAGE:-unknown}" | sed 's/.*://')
  
  log ""
  log "== create backup =="
  log ""
  printf "evi version: ${GREEN}%s${NC}\n" "${evi_version}"
  printf "pgadmin:     ${GREEN}%s${NC}\n" "${EVI_PGADMIN_ENABLED:-false}"
  log ""
  
  # Select backup location
  log "== backup location =="
  log ""
  log "  1) evi/backup"
  log "  2) enter custom path"
  get_mount_points 3
  log ""
  printf "${YELLOW}⚠️  tip: for better performance, choose a different disk than evi-db${NC}\n"
  log ""
  
  local backup_base_dir="${DEPLOYMENT_DIR}/backup"
  read -r -p "select option [default: evi/backup]: " location_choice
  
  if [[ -n "${location_choice}" ]]; then
    if [[ "${location_choice}" == "1" ]]; then
      backup_base_dir="${DEPLOYMENT_DIR}/backup"
    elif [[ "${location_choice}" == "2" ]]; then
      read -r -p "enter backup directory: " backup_base_dir
    elif [[ "${location_choice}" =~ ^[0-9]+$ ]] && [[ "${location_choice}" -ge 3 ]]; then
      local mount_point
      mount_point=$(get_mount_point_by_index "$((location_choice - 2))")
      if [[ -n "${mount_point}" ]]; then
        backup_base_dir="${mount_point}/evi-backups"
      fi
    else
      # Assume it's a path
      if [[ "${location_choice}" == /* ]] || [[ "${location_choice}" == ~* ]]; then
        backup_base_dir="${location_choice}"
      fi
    fi
  fi
  
  # Expand ~ if present
  backup_base_dir="${backup_base_dir/#\~/$HOME}"
  
  log ""
  
  # Select compression level
  log "compression:"
  
  # Get estimates if backup-estimate.sh exists
  local est_time_fast="~1 min" est_size_fast="~950 MB"
  local est_time_std="~4 min" est_size_std="~800 MB"
  local est_time_max="~12 min" est_size_max="~650 MB"
  
  if [[ -x "${SCRIPTS_DIR}/backup-estimate.sh" ]]; then
    local estimates
    estimates=$("${SCRIPTS_DIR}/backup-estimate.sh" "${backup_base_dir}" 2>/dev/null || echo "")
    if [[ -n "${estimates}" ]]; then
      # Parse JSON estimates (simple grep approach)
      local time_fast size_fast time_std size_std time_max size_max
      time_fast=$(echo "${estimates}" | grep -o '"zstd-fast"[^}]*"time_seconds"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "60")
      size_fast=$(echo "${estimates}" | grep -o '"zstd-fast"[^}]*"size_bytes"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "950000000")
      time_std=$(echo "${estimates}" | grep -o '"gzip-standard"[^}]*"time_seconds"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "240")
      size_std=$(echo "${estimates}" | grep -o '"gzip-standard"[^}]*"size_bytes"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "800000000")
      time_max=$(echo "${estimates}" | grep -o '"zstd-max"[^}]*"time_seconds"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "720")
      size_max=$(echo "${estimates}" | grep -o '"zstd-max"[^}]*"size_bytes"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*$' || echo "650000000")
      
      est_time_fast=$(format_time "${time_fast}")
      est_size_fast=$(format_bytes "${size_fast}")
      est_time_std=$(format_time "${time_std}")
      est_size_std=$(format_bytes "${size_std}")
      est_time_max=$(format_time "${time_max}")
      est_size_max=$(format_bytes "${size_max}")
    fi
  fi
  
  printf "  1) zstd-fast       %s, %s\n" "${est_time_fast}" "${est_size_fast}"
  printf "  2) gzip-standard   %s, %s    ${CYAN}[default]${NC}\n" "${est_time_std}" "${est_size_std}"
  printf "  3) zstd-max        %s, %s\n" "${est_time_max}" "${est_size_max}"
  log ""
  
  local compression="gzip-standard"
  read -r -p "select compression [2]: " comp_choice
  case "${comp_choice}" in
    1) compression="zstd-fast" ;;
    3) compression="zstd-max" ;;
    *) compression="gzip-standard" ;;
  esac
  
  log ""
  
  # Encryption
  local encrypt="true"
  local password=""
  read -r -p "encrypt backup with password? [Y/n]: " encrypt_choice
  if [[ "${encrypt_choice}" == "n" || "${encrypt_choice}" == "N" ]]; then
    encrypt="false"
  else
    while true; do
      read -r -s -p "enter password: " password
      echo ""
      read -r -s -p "confirm password: " password_confirm
      echo ""
      
      if [[ "${password}" == "${password_confirm}" ]]; then
        if [[ -z "${password}" ]]; then
          warn "password cannot be empty"
        else
          break
        fi
      else
        warn "passwords do not match, try again"
      fi
    done
  fi
  
  log ""
  
  # Create backup directory name with timestamp
  local timestamp
  timestamp=$(date +"%Y-%m-%d-%H%M%S")
  local backup_dir="${backup_base_dir}/evi-backup-v${evi_version}-${timestamp}"
  
  # Summary
  log "== summary =="
  log ""
  printf "  destination: ${CYAN}%s/${NC}\n" "${backup_dir}"
  log "  contents:"
  log "    - README-RESTORE-STEP-BY-STEP.md"
  printf "    - evi-v%s.tar.gz\n" "${evi_version}"
  printf "    - evi-data-v%s.tar.gz%s\n" "${evi_version}" "$([ "${encrypt}" = "true" ] && echo ".gpg")"
  log ""
  printf "  compression: ${GREEN}%s${NC}\n" "${compression}"
  printf "  encryption:  ${GREEN}%s${NC}\n" "$([ "${encrypt}" = "true" ] && echo "yes" || echo "no")"
  log ""
  printf "  estimated size: ${CYAN}%s${NC}\n" "${est_size_std}"
  printf "  estimated time: ${CYAN}%s${NC}\n" "${est_time_std}"
  log ""
  
  read -r -p "proceed? [Y/n]: " proceed
  if [[ "${proceed}" == "n" || "${proceed}" == "N" ]]; then
    log "backup cancelled."
    return 0
  fi
  
  # Create backup directory
  mkdir -p "${backup_dir}" || die "Cannot create backup directory: ${backup_dir}"
  
  # Export environment variables for backup-create.sh
  export BACKUP_DIR="${backup_dir}"
  export BACKUP_COMPRESSION="${compression}"
  export BACKUP_ENCRYPT="${encrypt}"
  export BACKUP_PASSWORD="${password}"
  export EVI_VERSION="${evi_version}"
  
  # Run backup script
  chmod +x "${SCRIPTS_DIR}/backup-create.sh"
  "${SCRIPTS_DIR}/backup-create.sh"
  local exit_code=$?
  
  if [[ ${exit_code} -eq 0 ]]; then
    log ""
    read -r -p "verify backup integrity? [y/N]: " verify_choice
    if [[ "${verify_choice}" == "y" || "${verify_choice}" == "Y" ]]; then
      chmod +x "${SCRIPTS_DIR}/backup-verify.sh"
      "${SCRIPTS_DIR}/backup-verify.sh" "${backup_dir}" "${password}"
    fi
  else
    err "Backup failed with exit code ${exit_code}"
    return ${exit_code}
  fi
}

cmd_restore() {
  local archive_path="${1:-}"
  
  if [[ -z "${archive_path}" ]]; then
    log ""
    log "== restore from backup =="
    log ""
    read -r -p "enter path to evi-data archive: " archive_path
  fi
  
  if [[ -z "${archive_path}" ]]; then
    die "No archive path provided"
  fi
  
  if [[ ! -f "${archive_path}" ]]; then
    die "Archive not found: ${archive_path}"
  fi
  
  chmod +x "${SCRIPTS_DIR}/backup-restore.sh"
  "${SCRIPTS_DIR}/backup-restore.sh" "${archive_path}"
}

cmd_backup_info() {
  local backup_dir="${1:-}"
  
  if [[ -z "${backup_dir}" ]]; then
    die "Usage: evictl backup-info <backup-directory>"
  fi
  
  if [[ ! -d "${backup_dir}" ]]; then
    die "Backup directory not found: ${backup_dir}"
  fi
  
  log ""
  log "== backup information =="
  log ""
  log "location: ${backup_dir}"
  log ""
  
  # List files
  log "files:"
  for f in "${backup_dir}"/*; do
    if [[ -f "${f}" ]]; then
      local size
      size=$(stat -c%s "${f}" 2>/dev/null || stat -f%z "${f}" 2>/dev/null || echo "0")
      printf "  %-50s %s\n" "$(basename "${f}")" "$(format_bytes "${size}")"
    fi
  done
  log ""
  
  # Show README if exists
  if [[ -f "${backup_dir}/README-RESTORE-STEP-BY-STEP.md" ]]; then
    log "restore instructions:"
    log ""
    head -50 "${backup_dir}/README-RESTORE-STEP-BY-STEP.md" | sed 's/^/  /'
    log ""
  fi
}

usage() {
  cat <<'EOF'
evictl - evi production deployment controller

Usage:
  evictl <command>
  evictl               # interactive menu

Commands:
  up              Start services
  down            Stop services
  restart         Restart services
  status          Show systemd user unit status
  logs [unit]     Show recent logs (default: evi-reverse-proxy)
  health          Check health of all services
  cert <subcmd>   Certificate management:
                    info    - Show certificate information
                    check   - Check certificate expiry
                    regen   - Regenerate certificates (manual mode)
                    install - Show client installation instructions
  env-info        Show environment information (includes certificate info)
  info            Show cockpit & pgadmin help
  backup          Create full backup (interactive)
  restore <path>  Restore from backup archive
  backup-info <dir> Show backup information
  self-update     Update evictl (not implemented yet)
EOF
}

menu() {
  while true; do
    echo ""
    echo "+--------------------------------------------------------------+"
    printf "| %-60s |\n" "evi prod manager (evictl) v.${EVICTL_VERSION}"
    echo "+--------------------------------------------------------------+"
    
    display_container_status_table
    
    echo "0) exit"
    echo ""
    echo "container management:"
    echo "1) start containers"
    echo "2) stop containers"
    echo "3) restart containers"
    echo ""
    echo "view logs:"
    echo "4) view logs: evi-reverse-proxy"
    echo "5) view logs: evi-fe"
    echo "6) view logs: evi-be"
    echo "7) view logs: evi-db"
    
    # Check if pgAdmin is enabled (try to load env, but don't fail if missing)
    local pgadmin_enabled="false"
    if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]]; then
      # shellcheck disable=SC1090
      pgadmin_enabled=$(grep "^EVI_PGADMIN_ENABLED=" "${EVI_ENV_FILE_DEFAULT}" 2>/dev/null | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' || echo "false")
    fi
    if [[ "${pgadmin_enabled}" == "true" ]]; then
      echo "8) view logs: evi-pgadmin"
    fi
    echo ""
    echo "monitoring:"
    echo "9) health check"
    echo ""
    echo "backup & restore:"
    echo "10) create backup"
    echo "11) restore from backup"
    echo ""
    echo "information:"
    echo "12) environment info (includes certificate info)"
    echo "13) cockpit & pgadmin help"
    echo ""
    
    read -r -p "select option: " choice
    case "${choice}" in
      1) cmd_up ;;
      2) cmd_down ;;
      3) cmd_restart ;;
      4) cmd_logs "evi-reverse-proxy" ;;
      5) cmd_logs "evi-fe" ;;
      6) cmd_logs "evi-be" ;;
      7) cmd_logs "evi-db" ;;
      8)
        local pgadmin_enabled="false"
        if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]]; then
          pgadmin_enabled=$(grep "^EVI_PGADMIN_ENABLED=" "${EVI_ENV_FILE_DEFAULT}" 2>/dev/null | cut -d'=' -f2 | tr -d '"' | tr -d "'" | tr '[:upper:]' '[:lower:]' || echo "false")
        fi
        if [[ "${pgadmin_enabled}" == "true" ]]; then
          cmd_logs "evi-pgadmin"
        else
          warn "invalid option."
        fi
        ;;
      9) cmd_health ;;
      10) cmd_backup ;;
      11) cmd_restore ;;
      12) cmd_env_info ;;
      13) cmd_info ;;
      0) exit 0 ;;
      *) warn "invalid option." ;;
    esac
  done
}

main() {
  if [[ "${#}" -eq 0 ]]; then
    menu
    return 0
  fi

  local cmd="$1"; shift || true
  case "${cmd}" in
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    restart) cmd_restart "$@" ;;
    status) cmd_status "$@" ;;
    logs) cmd_logs "$@" ;;
    health) cmd_health "$@" ;;
    cert) cmd_cert "$@" ;;
    env-info) cmd_env_info "$@" ;;
    info) cmd_info "$@" ;;
    backup) cmd_backup "$@" ;;
    restore) cmd_restore "$@" ;;
    backup-info) cmd_backup_info "$@" ;;
    self-update) cmd_self_update "$@" ;;
    -h|--help|help) usage ;;
    *) usage; die "Unknown command: ${cmd}" ;;
  esac
}

main "$@"
