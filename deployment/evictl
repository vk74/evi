#!/usr/bin/env bash
#
# Version: 1.5.5
# Purpose: evi production deployment controller (rootless Podman + Quadlet).
# Deployment file: evictl
# Logic:
# - Provides CLI subcommands (init/up/down/restart/status/logs/update/doctor/health/cert/build/cleanup)
# - Provides interactive menu mode when run without args
# - Renders Quadlet units from templates, renders Caddyfile, and manages secrets
#
# Changes in v1.5.5:
# - Fixed frontend-backend connection in production: added --build-arg VUE_APP_API_URL=/api to frontend build
# - Frontend now uses relative path /api for API calls (works with Caddy reverse proxy)
#
# Changes in v1.5.4:
# - Fixed pgAdmin permission error: set ownership of data directory to UID 5050
# - Used podman unshare chown for rootless Podman compatibility
#
# Changes in v1.5.3:
# - Fixed pgAdmin not starting: added load_env_files() call to cmd_up()
# - Added pgAdmin support to cmd_down(), cmd_restart(), cmd_status()
# - Added EVI_PGADMIN_EMAIL to template rendering keys
# - Added pgadmin/data directory creation for persistent storage
#
# Changes in v1.5.2:
# - Fixed unbound variable error for EVI_PGADMIN_ENABLED
# - Added default values for all EVI_PGADMIN_* variables in load_env_files
#
# Changes in v1.5.1:
# - Updated pgAdmin rendering: removed auth credentials, added localhost-only binding
# - Added servers.json rendering for pre-configured evi-db connection in pgAdmin
# - Added EVI_ADMIN_DB_USERNAME, EVI_PGADMIN_HOST, EVI_PGADMIN_PORT to template rendering
#
# Changes in v1.5.0:
# - Added cleanup command to remove source code files after successful deployment
# - Cleanup prompt appears automatically after successful evictl up (interactive mode)
# - Cleanup verifies deployment is running before removing files
# - Cleanup removes: back/, front/, db/, docs/, README.md, package.json, package-lock.json, .git/
#
# Changes in v1.4.0:
# - Added health command for comprehensive service health checks
# - Added cert command with subcommands: info, check, regen, install
# - Lowercase styling for menu and messages
#
# Changes in v1.3.0:
# - Fixed TLS handshake error by using port-based Caddy binding instead of domain-based
# - Added auto_https off for manual TLS mode
# - Refactored Caddyfile rendering with EVI_CADDY_GLOBAL_OPTIONS and EVI_HTTP_REDIRECT_BLOCK
# - Removed internal TLS mode (simplified to manual and letsencrypt only)
#
# Changes in v1.2.1:
# - Fixed unbound variable error: EVI_TLS_CERT_IN_CONTAINER now set in render_caddyfile()
#
# Changes in v1.2.0:
# - Updated manual TLS mode to auto-detect certificates from deployment/env/tls/
# - Removed internal TLS mode recommendation in favor of manual mode with self-signed certs
# - Improved certificate path resolution (supports absolute and relative paths)
#
# Changes in v1.1.4:
# - Updated internal TLS configuration to use sign_with_root option
# - This fixes TLS handshake errors caused by intermediate CA chain issues
#
# Changes in v1.1.3:
# - Fixed EVI_CADDY_EMAIL_BLOCK placeholder not being processed in render_template_file
# - Simplified internal TLS configuration to avoid syntax errors
#
# Changes in v1.1.2:
# - Fixed internal TLS mode for IP addresses: disabled global email to prevent automatic ACME attempts
# - Updated Caddyfile.site.internal.template to use explicit issuer configuration
# - Added sign_with_root option for better certificate compatibility
#
# Changes in v1.1.1:
# - Added internal TLS mode support (Caddy local CA).
# - Added strict validation for EVI_TLS_MODE and EVI_DOMAIN.
# - Updated doctor check for unprivileged port start.
#
# Changes in v1.1.0:
# - Added 'build' command to build images from source using tags from env file.
#
# Changes in v1.0.0:
# - Initial CLI + menu tool for prod deployment using Caddy reverse-proxy on 80/443
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOYMENT_DIR="${SCRIPT_DIR}"
ENV_DIR="${DEPLOYMENT_DIR}/env"
TPL_DIR="${DEPLOYMENT_DIR}/quadlet-templates"
PROXY_DIR="${DEPLOYMENT_DIR}/proxy"
SCRIPTS_DIR="${DEPLOYMENT_DIR}/scripts"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

EVI_STATE_DIR_DEFAULT="${HOME}/.local/share/evi"
EVI_CONFIG_DIR_DEFAULT="${HOME}/.config/evi"
EVI_QUADLET_DIR_DEFAULT="${HOME}/.config/containers/systemd"

EVI_ENV_FILE_DEFAULT="${ENV_DIR}/evi.env"
EVI_SECRETS_FILE_DEFAULT="${ENV_DIR}/evi.secrets.env"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

log() { printf "%s\n" "$*"; }
warn() { printf "WARN: %s\n" "$*" >&2; }
die() { printf "ERROR: %s\n" "$*" >&2; exit 1; }

require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

load_env_files() {
  # shellcheck disable=SC1090
  if [[ -f "${EVI_ENV_FILE_DEFAULT}" ]]; then 
    source "${EVI_ENV_FILE_DEFAULT}"
  else 
    # Fallback to template ONLY if main env is missing? 
    # No, for prod we should fail or warn heavily.
    # But for fresh install, init might need to read something.
    # However, init usually happens AFTER config wizard.
    die "Missing config file: ${EVI_ENV_FILE_DEFAULT}. Run install.sh or configure first."
  fi
  
  # shellcheck disable=SC1090
  if [[ -f "${EVI_SECRETS_FILE_DEFAULT}" ]]; then 
    source "${EVI_SECRETS_FILE_DEFAULT}"
  else 
    die "Missing secrets file: ${EVI_SECRETS_FILE_DEFAULT}. Run install.sh or configure first."
  fi

  export EVI_STATE_DIR="${EVI_STATE_DIR:-${EVI_STATE_DIR_DEFAULT}}"
  export EVI_CONFIG_DIR="${EVI_CONFIG_DIR:-${EVI_CONFIG_DIR_DEFAULT}}"
  export EVI_QUADLET_DIR="${EVI_QUADLET_DIR:-${EVI_QUADLET_DIR_DEFAULT}}"

  export EVI_JWT_SECRET_NAME="${EVI_JWT_SECRET_NAME:-evi_jwt_private_key}"
  
  # Default admin username if not set
  export EVI_ADMIN_DB_USERNAME="${EVI_ADMIN_DB_USERNAME:-evidba}"
  
  # Default pgAdmin settings (disabled by default)
  export EVI_PGADMIN_ENABLED="${EVI_PGADMIN_ENABLED:-false}"
  export EVI_PGADMIN_IMAGE="${EVI_PGADMIN_IMAGE:-docker.io/dpage/pgadmin4:8}"
  export EVI_PGADMIN_HOST="${EVI_PGADMIN_HOST:-127.0.0.1}"
  export EVI_PGADMIN_PORT="${EVI_PGADMIN_PORT:-5445}"
  export EVI_PGADMIN_EMAIL="${EVI_PGADMIN_EMAIL:-}"

  # Validation
  [[ -n "${EVI_DOMAIN:-}" ]] || die "EVI_DOMAIN is not set in evi.env"
  
  EVI_TLS_MODE="${EVI_TLS_MODE:-letsencrypt}"
  if [[ "${EVI_TLS_MODE}" != "letsencrypt" && "${EVI_TLS_MODE}" != "manual" ]]; then
    die "Invalid EVI_TLS_MODE: '${EVI_TLS_MODE}'. Must be one of: letsencrypt, manual."
  fi
}

ensure_dirs() {
  mkdir -p "${EVI_STATE_DIR}/proxy" "${EVI_STATE_DIR}/tls" "${EVI_STATE_DIR}/secrets"
  mkdir -p "${EVI_STATE_DIR}/pgadmin" "${EVI_STATE_DIR}/pgadmin/data"
  mkdir -p "${EVI_CONFIG_DIR}"
  mkdir -p "${EVI_QUADLET_DIR}"
  
  # pgAdmin runs as UID 5050 inside the container.
  # For rootless Podman, we need to map this UID to host using podman unshare.
  if [[ -d "${EVI_STATE_DIR}/pgadmin/data" ]]; then
    # Use podman unshare to set ownership within user namespace
    podman unshare chown 5050:5050 "${EVI_STATE_DIR}/pgadmin/data" 2>/dev/null || true
  fi
}

render_template_file() {
  local in_file="$1"
  local out_file="$2"
  shift 2

  local content
  content="$(cat "${in_file}")"

  # Replace {{KEY}} placeholders based on exported env vars.
  # Note: Keep this simple and deterministic for MVP.
  local keys=(
    EVI_DOMAIN EVI_ACME_EMAIL EVI_TLS_MODE
    EVI_HTTP_PORT EVI_HTTPS_PORT
    EVI_PROXY_IMAGE EVI_FE_IMAGE EVI_BE_IMAGE EVI_DB_IMAGE
    EVI_NETWORK EVI_BE_PORT EVI_FE_PORT EVI_DB_PORT
    EVI_NODE_ENV EVI_CORS_ORIGINS
    EVI_POSTGRES_DB EVI_POSTGRES_USER EVI_POSTGRES_PASSWORD EVI_APP_DB_PASSWORD EVI_ADMIN_DB_USERNAME EVI_ADMIN_DB_PASSWORD EVI_SEED_DEMO_DATA
    EVI_STATE_DIR EVI_JWT_SECRET_NAME
    EVI_PGADMIN_IMAGE EVI_PGADMIN_HOST EVI_PGADMIN_PORT EVI_PGADMIN_EMAIL
  )

  local k v
  for k in "${keys[@]}"; do
    v="${!k-}"
    content="${content//\{\{${k}\}\}/${v}}"
  done

  # Render dynamic blocks prepared by caller (placeholders remain if unset)
  content="${content//\{\{EVI_PODMANARGS_LIMITS_PROXY\}\}/${EVI_PODMANARGS_LIMITS_PROXY-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_FE\}\}/${EVI_PODMANARGS_LIMITS_FE-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_BE\}\}/${EVI_PODMANARGS_LIMITS_BE-}}"
  content="${content//\{\{EVI_PODMANARGS_LIMITS_DB\}\}/${EVI_PODMANARGS_LIMITS_DB-}}"
  content="${content//\{\{EVI_PROXY_TLS_MOUNTS\}\}/${EVI_PROXY_TLS_MOUNTS-}}"
  content="${content//\{\{EVI_TLS_SITE_BLOCK\}\}/${EVI_TLS_SITE_BLOCK-}}"
  content="${content//\{\{EVI_CADDY_EMAIL_BLOCK\}\}/${EVI_CADDY_EMAIL_BLOCK-}}"
  content="${content//\{\{EVI_CADDY_GLOBAL_OPTIONS\}\}/${EVI_CADDY_GLOBAL_OPTIONS-}}"
  content="${content//\{\{EVI_HTTP_REDIRECT_BLOCK\}\}/${EVI_HTTP_REDIRECT_BLOCK-}}"

  printf "%s\n" "${content}" > "${out_file}"
}

compute_limits_block() {
  # Build PodmanArgs lines for limits (CPU/memory) based on env.
  # We keep them empty if unset.
  local cpu="$1"
  local mem="$2"
  local out=""

  if [[ -n "${cpu}" ]]; then
    out+=$'PodmanArgs=--cpus='"${cpu}"$'\n'
  fi
  if [[ -n "${mem}" ]]; then
    out+=$'PodmanArgs=--memory='"${mem}"$'\n'
  fi

  printf "%s" "${out}"
}

prepare_proxy_tls_mounts() {
  # For manual TLS, we mount cert/key from state dir into container.
  if [[ "${EVI_TLS_MODE}" == "manual" ]]; then
    export EVI_TLS_CERT_IN_CONTAINER="/etc/evi-tls/cert.pem"
    export EVI_TLS_KEY_IN_CONTAINER="/etc/evi-tls/key.pem"
    export EVI_PROXY_TLS_MOUNTS=$'Volume='"${EVI_STATE_DIR}"$'/tls/cert.pem:'"${EVI_TLS_CERT_IN_CONTAINER}"$':ro,Z\nVolume='"${EVI_STATE_DIR}"$'/tls/key.pem:'"${EVI_TLS_KEY_IN_CONTAINER}"$':ro,Z\n'
  else
    export EVI_PROXY_TLS_MOUNTS=""
  fi
}

render_caddyfile() {
  local base_tpl="${PROXY_DIR}/Caddyfile.template"
  local site_tpl=""

  # Build global options based on TLS mode
  if [[ "${EVI_TLS_MODE}" == "manual" ]]; then
    # Manual TLS requires auto_https off to prevent Caddy from interfering
    export EVI_CADDY_GLOBAL_OPTIONS="auto_https off"
    # HTTP redirect uses port-based binding for manual mode
    export EVI_HTTP_REDIRECT_BLOCK=":${EVI_HTTP_PORT} {
	redir https://${EVI_DOMAIN}{uri} permanent
}"
    # Set container paths for manual TLS mode (fixed paths inside container)
    export EVI_TLS_CERT_IN_CONTAINER="/etc/evi-tls/cert.pem"
    export EVI_TLS_KEY_IN_CONTAINER="/etc/evi-tls/key.pem"
    
    site_tpl="${PROXY_DIR}/Caddyfile.site.manual.template"
    export EVI_TLS_SITE_BLOCK="$(cat "${site_tpl}")"
    export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_TLS_CERT_IN_CONTAINER\}\}/${EVI_TLS_CERT_IN_CONTAINER}}"
    export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_TLS_KEY_IN_CONTAINER\}\}/${EVI_TLS_KEY_IN_CONTAINER}}"
  else
    # Let's Encrypt mode - need email for ACME
    export EVI_CADDY_GLOBAL_OPTIONS="email ${EVI_ACME_EMAIL:-admin@example.com}"
    export EVI_HTTP_REDIRECT_BLOCK="http://${EVI_DOMAIN}:${EVI_HTTP_PORT} {
	redir https://${EVI_DOMAIN}{uri} permanent
}"
    site_tpl="${PROXY_DIR}/Caddyfile.site.letsencrypt.template"
    export EVI_TLS_SITE_BLOCK="$(cat "${site_tpl}")"
  fi

  # Replace the common placeholders inside the site block
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_DOMAIN\}\}/${EVI_DOMAIN}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_HTTP_PORT\}\}/${EVI_HTTP_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_HTTPS_PORT\}\}/${EVI_HTTPS_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_BE_PORT\}\}/${EVI_BE_PORT}}"
  export EVI_TLS_SITE_BLOCK="${EVI_TLS_SITE_BLOCK//\{\{EVI_FE_PORT\}\}/${EVI_FE_PORT}}"

  render_template_file "${base_tpl}" "${EVI_STATE_DIR}/proxy/Caddyfile"
  log "OK: rendered Caddyfile to ${EVI_STATE_DIR}/proxy/Caddyfile"
}

create_or_update_secret_from_file() {
  local secret_name="$1"
  local file_path="$2"

  [[ -f "${file_path}" ]] || die "Secret source file not found: ${file_path}"

  if podman secret inspect "${secret_name}" >/dev/null 2>&1; then
    podman secret rm "${secret_name}" >/dev/null
  fi
  podman secret create "${secret_name}" "${file_path}" >/dev/null
}

prepare_jwt_secret() {
  require_cmd podman

  local target="${EVI_STATE_DIR}/secrets/jwt_private_key.pem"

  if [[ "${EVI_JWT_GENERATE_KEY}" == "true" ]]; then
    log "Generating new JWT key pair..."
    require_cmd openssl
    # Ensure script is executable
    chmod +x "${SCRIPTS_DIR}/gen-jwt-rs256-keypair.sh"
    "${SCRIPTS_DIR}/gen-jwt-rs256-keypair.sh" "${EVI_STATE_DIR}/secrets" "jwt_private_key.pem" >/dev/null
    log "OK: JWT key pair generated."
  elif [[ -n "${EVI_JWT_PRIVATE_KEY_PEM_PATH}" ]]; then
    log "Using provided JWT key from file..."
    cp -f "${EVI_JWT_PRIVATE_KEY_PEM_PATH}" "${target}"
    chmod 600 "${target}"
  elif [[ -n "${EVI_JWT_PRIVATE_KEY_PEM_INLINE}" ]]; then
    log "Using provided JWT key from inline config..."
    printf "%s\n" "${EVI_JWT_PRIVATE_KEY_PEM_INLINE}" > "${target}"
    chmod 600 "${target}"
  else
    die "JWT key not provided. Set EVI_JWT_GENERATE_KEY=true or provide EVI_JWT_PRIVATE_KEY_PEM_PATH or EVI_JWT_PRIVATE_KEY_PEM_INLINE."
  fi

  create_or_update_secret_from_file "${EVI_JWT_SECRET_NAME}" "${target}"
  log "OK: created/updated podman secret ${EVI_JWT_SECRET_NAME}"
}

resolve_tls_path() {
  # Resolve TLS file path - supports absolute and relative paths
  local path="$1"
  
  if [[ -z "${path}" ]]; then
    echo ""
    return
  fi
  
  # If absolute path, use as-is
  if [[ "${path}" == /* ]]; then
    echo "${path}"
    return
  fi
  
  # Try relative to ENV_DIR first
  if [[ -f "${ENV_DIR}/${path}" ]]; then
    echo "${ENV_DIR}/${path}"
    return
  fi
  
  # Try relative to DEPLOYMENT_DIR
  if [[ -f "${DEPLOYMENT_DIR}/${path}" ]]; then
    echo "${DEPLOYMENT_DIR}/${path}"
    return
  fi
  
  # Return original (let caller handle error)
  echo "${path}"
}

prepare_manual_tls_files() {
  if [[ "${EVI_TLS_MODE}" != "manual" ]]; then
    return 0
  fi

  local cert_path="${EVI_TLS_CERT_PATH:-}"
  local key_path="${EVI_TLS_KEY_PATH:-}"
  
  # Auto-detect from default TLS directory if not specified
  local default_tls_dir="${ENV_DIR}/tls"
  
  if [[ -z "${cert_path}" && -f "${default_tls_dir}/cert.pem" ]]; then
    cert_path="${default_tls_dir}/cert.pem"
    log "Auto-detected certificate: ${cert_path}"
  fi
  
  if [[ -z "${key_path}" && -f "${default_tls_dir}/key.pem" ]]; then
    key_path="${default_tls_dir}/key.pem"
    log "Auto-detected private key: ${key_path}"
  fi
  
  # Resolve paths (handle relative paths)
  cert_path=$(resolve_tls_path "${cert_path}")
  key_path=$(resolve_tls_path "${key_path}")

  if [[ -n "${cert_path}" && -n "${key_path}" ]]; then
    if [[ ! -f "${cert_path}" ]]; then
      die "TLS certificate not found: ${cert_path}"
    fi
    if [[ ! -f "${key_path}" ]]; then
      die "TLS private key not found: ${key_path}"
    fi
    
    log "Importing manual TLS certificates..."
    chmod +x "${SCRIPTS_DIR}/import-tls.sh"
    "${SCRIPTS_DIR}/import-tls.sh" "${cert_path}" "${key_path}" "${EVI_STATE_DIR}/tls" >/dev/null
    log "OK: imported manual TLS cert/key to ${EVI_STATE_DIR}/tls"
    return 0
  fi

  die "Manual TLS selected but certificates not found. Either:
  1. Generate certificates using install.sh -> TLS Certificates menu
  2. Set EVI_TLS_CERT_PATH and EVI_TLS_KEY_PATH in evi.secrets.env
  3. Place cert.pem and key.pem in ${default_tls_dir}/"
}

render_quadlets() {
  # Compute optional limits
  export EVI_PODMANARGS_LIMITS_PROXY
  export EVI_PODMANARGS_LIMITS_FE
  export EVI_PODMANARGS_LIMITS_BE
  export EVI_PODMANARGS_LIMITS_DB

  EVI_PODMANARGS_LIMITS_PROXY="$(compute_limits_block "${EVI_LIMIT_CPU_PROXY-}" "${EVI_LIMIT_MEM_PROXY-}")"
  EVI_PODMANARGS_LIMITS_FE="$(compute_limits_block "${EVI_LIMIT_CPU_FE-}" "${EVI_LIMIT_MEM_FE-}")"
  EVI_PODMANARGS_LIMITS_BE="$(compute_limits_block "${EVI_LIMIT_CPU_BE-}" "${EVI_LIMIT_MEM_BE-}")"
  EVI_PODMANARGS_LIMITS_DB="$(compute_limits_block "${EVI_LIMIT_CPU_DB-}" "${EVI_LIMIT_MEM_DB-}")"

  prepare_proxy_tls_mounts

  render_template_file "${TPL_DIR}/evi.network" "${EVI_QUADLET_DIR}/evi.network"
  render_template_file "${TPL_DIR}/evi-db.volume" "${EVI_QUADLET_DIR}/evi-db.volume"

  render_template_file "${TPL_DIR}/evi-db.container" "${EVI_QUADLET_DIR}/evi-db.container"
  render_template_file "${TPL_DIR}/evi-be.container" "${EVI_QUADLET_DIR}/evi-be.container"
  render_template_file "${TPL_DIR}/evi-fe.container" "${EVI_QUADLET_DIR}/evi-fe.container"
  render_template_file "${TPL_DIR}/evi-proxy.container" "${EVI_QUADLET_DIR}/evi-proxy.container"

  # Optional pgAdmin
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    # Render pgAdmin container quadlet
    render_template_file "${TPL_DIR}/evi-pgadmin.container" "${EVI_QUADLET_DIR}/evi-pgadmin.container"
    
    # Render servers.json for pre-configured evi-db connection
    local pgadmin_tpl="${DEPLOYMENT_DIR}/pgadmin/servers.json.template"
    local pgadmin_out="${EVI_STATE_DIR}/pgadmin/servers.json"
    if [[ -f "${pgadmin_tpl}" ]]; then
      local servers_content
      servers_content="$(cat "${pgadmin_tpl}")"
      servers_content="${servers_content//\{\{EVI_ADMIN_DB_USERNAME\}\}/${EVI_ADMIN_DB_USERNAME:-evidba}}"
      printf "%s\n" "${servers_content}" > "${pgadmin_out}"
      log "OK: rendered pgAdmin servers.json"
    else
      warn "pgAdmin servers.json template not found at ${pgadmin_tpl}"
    fi
  else
    # Remove if disabled/exists
    if [[ -f "${EVI_QUADLET_DIR}/evi-pgadmin.container" ]]; then
      rm "${EVI_QUADLET_DIR}/evi-pgadmin.container"
    fi
  fi

  log "OK: rendered Quadlet files into ${EVI_QUADLET_DIR}"
}

systemd_user_daemon_reload() {
  systemctl --user daemon-reload
}

cmd_init() {
  require_cmd podman
  require_cmd systemctl

  load_env_files
  ensure_dirs

  # Validate minimal required config
  [[ -n "${EVI_DOMAIN}" ]] || die "EVI_DOMAIN is required"
  [[ -n "${EVI_PROXY_IMAGE}" ]] || die "EVI_PROXY_IMAGE is required"
  [[ -n "${EVI_FE_IMAGE}" ]] || die "EVI_FE_IMAGE is required"
  [[ -n "${EVI_BE_IMAGE}" ]] || die "EVI_BE_IMAGE is required"
  [[ -n "${EVI_DB_IMAGE}" ]] || die "EVI_DB_IMAGE is required"
  
  # Validate pgAdmin email if enabled
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    if [[ -z "${EVI_PGADMIN_EMAIL}" ]]; then
      die "EVI_PGADMIN_EMAIL is required when EVI_PGADMIN_ENABLED=true. Set it in evi.env or use install.sh to configure pgAdmin"
    fi
    # Basic email format validation (reject .local and localhost)
    if [[ "${EVI_PGADMIN_EMAIL}" =~ \.local$ ]] || [[ "${EVI_PGADMIN_EMAIL}" =~ @localhost$ ]] || [[ ! "${EVI_PGADMIN_EMAIL}" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
      die "EVI_PGADMIN_EMAIL must be a valid email address (e.g., admin@example.com). Cannot use .local or localhost domain"
    fi
  fi

  # Secrets
  prepare_jwt_secret
  prepare_manual_tls_files

  # Proxy config
  render_caddyfile

  # Quadlets
  render_quadlets

  systemd_user_daemon_reload
  log "OK: init completed."
}

cmd_build() {
  require_cmd podman
  load_env_files
  
  log "Building images from source..."
  
  # Build DB
  if [[ -d "${PROJECT_ROOT}/db" ]]; then
    log "Building Database image: ${EVI_DB_IMAGE}"
    podman build -t "${EVI_DB_IMAGE}" "${PROJECT_ROOT}/db" &
    pids[0]=$!
  else
    warn "DB source directory not found at ${PROJECT_ROOT}/db"
  fi

  # Build Backend
  if [[ -d "${PROJECT_ROOT}/back" ]]; then
    log "Building Backend image: ${EVI_BE_IMAGE}"
    podman build -t "${EVI_BE_IMAGE}" "${PROJECT_ROOT}/back" &
    pids[1]=$!
  else
    warn "Backend source directory not found at ${PROJECT_ROOT}/back"
  fi

  # Build Frontend
  if [[ -d "${PROJECT_ROOT}/front" ]]; then
    log "Building Frontend image: ${EVI_FE_IMAGE}"
    # Pass build arg for API URL: use relative path /api for reverse proxy
    # Frontend and backend are on the same domain via Caddy, so relative path works
    podman build --build-arg VUE_APP_API_URL="${EVI_FE_API_URL:-/api}" -t "${EVI_FE_IMAGE}" "${PROJECT_ROOT}/front" &
    pids[2]=$!
  else
    warn "Frontend source directory not found at ${PROJECT_ROOT}/front"
  fi
  
  # Wait for all builds
  for pid in ${pids[*]}; do
    wait $pid
  done
  
  log "OK: Build completed."
}

cmd_up() {
  require_cmd systemctl
  load_env_files
  
  # Reload systemd units in case they were changed
  systemctl --user daemon-reload
  
  systemctl --user start evi-network.service evi-db-volume.service || true
  # Explicitly start services (autostart is handled by [Install] via generator)
  systemctl --user start evi-db evi-be evi-fe evi-proxy
  
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    if ! systemctl --user start evi-pgadmin; then
      warn "Failed to start evi-pgadmin service. Check logs with: journalctl --user -u evi-pgadmin"
      return 1
    fi
    # Give it a moment to start and check if it's running
    sleep 2
    if ! systemctl --user is-active --quiet evi-pgadmin; then
      warn "evi-pgadmin service started but is not active. Check logs with: journalctl --user -u evi-pgadmin"
    fi
  fi
  
  log "OK: started services."
  
  # Offer cleanup option after successful deployment (only in interactive mode)
  if [[ -t 0 ]]; then
    echo ""
    log "deployment successful!"
    echo ""
    log "cleanup option:"
    echo ""
    echo "source code files (back/, front/, db/, docs/, README.md, etc.) are no longer"
    echo "needed after successful deployment. you can remove them to save disk space."
    echo ""
    echo "files that will be kept:"
    echo "  - deployment/ (install.sh, evictl, configs, scripts, templates)"
    echo ""
    echo "files that will be removed:"
    echo "  - back/ (backend source code)"
    echo "  - front/ (frontend source code)"
    echo "  - db/ (database source code)"
    echo "  - docs/ (developer documentation)"
    echo "  - README.md (installation guide)"
    echo "  - package.json, package-lock.json"
    echo "  - .git/ (if exists)"
    echo ""
    
    local reply
    read -r -p "do you want to remove source code files now? [y/N]: " reply
    if [[ "${reply}" =~ ^[Yy]$ ]]; then
      echo ""
      cmd_cleanup
    else
      log "cleanup skipped. you can run cleanup later using: evictl cleanup"
    fi
  fi
}

cmd_down() {
  require_cmd systemctl
  load_env_files
  
  # Stop pgAdmin first if enabled
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    systemctl --user stop evi-pgadmin || true
  fi
  
  systemctl --user stop evi-proxy evi-fe evi-be evi-db || true
  log "OK: stopped services."
}

cmd_restart() {
  require_cmd systemctl
  load_env_files
  
  systemctl --user restart evi-db evi-be evi-fe evi-proxy
  
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    systemctl --user restart evi-pgadmin
  fi
  
  log "OK: restarted services."
}

cmd_status() {
  require_cmd systemctl
  load_env_files
  
  local services="evi-proxy evi-fe evi-be evi-db"
  if [[ "${EVI_PGADMIN_ENABLED:-false}" == "true" ]]; then
    services="${services} evi-pgadmin"
  fi
  
  systemctl --user status ${services} --no-pager || true
}

cmd_logs() {
  require_cmd journalctl
  local unit="${1:-evi-proxy}"
  journalctl --user -u "${unit}" -n 200 --no-pager || true
}

cmd_update() {
  require_cmd podman
  load_env_files
  podman pull "${EVI_PROXY_IMAGE}"
  podman pull "${EVI_FE_IMAGE}"
  podman pull "${EVI_BE_IMAGE}"
  podman pull "${EVI_DB_IMAGE}"
  cmd_restart
  log "OK: images pulled and services restarted."
}

cmd_doctor() {
  require_cmd podman
  require_cmd systemctl

  log "== doctor =="
  log "podman: $(podman --version)"
  log "systemctl --user: OK"

  if command -v sysctl >/dev/null 2>&1; then
    local v
    v="$(sysctl -n net.ipv4.ip_unprivileged_port_start 2>/dev/null || echo "")"
    if [[ "$v" == "80" ]]; then
      log "net.ipv4.ip_unprivileged_port_start=80 (OK)"
    else
      warn "net.ipv4.ip_unprivileged_port_start=${v} (Expected 80 for rootless port 80/443 binding)"
      warn "  -> Run 'install.sh' -> Prerequisites -> 1 or 2 to fix this."
    fi
  fi

  if command -v timedatectl >/dev/null 2>&1; then
    log "NTPSynchronized: $(timedatectl show -p NTPSynchronized --value 2>/dev/null || echo "unknown")"
  fi
}

cmd_self_update() {
  die "self-update not implemented yet (MVP placeholder)."
}

cmd_health() {
  require_cmd podman
  load_env_files
  
  log "== health check =="
  echo ""
  
  local all_ok=true
  
  # Check containers
  log "containers:"
  local containers=("evi-db" "evi-be" "evi-fe" "evi-proxy")
  for c in "${containers[@]}"; do
    local status
    status=$(podman ps --filter "name=^${c}$" --format "{{.Status}}" 2>/dev/null || echo "")
    if [[ -n "${status}" ]]; then
      printf "  %-12s ${GREEN}running${NC} (%s)\n" "${c}:" "${status}"
    else
      printf "  %-12s ${RED}not running${NC}\n" "${c}:"
      all_ok=false
    fi
  done
  echo ""
  
  # Check database connectivity using app_service account
  log "database:"
  if podman ps --filter "name=^evi-db$" --format "{{.Status}}" 2>/dev/null | grep -q "healthy"; then
    printf "  %-12s ${GREEN}healthy${NC}\n" "status:"
    
    # Try to connect with app_service
    local db_test
    db_test=$(podman exec evi-db psql -U app_service -d maindb -c "SELECT 1;" 2>&1 || echo "FAIL")
    if echo "${db_test}" | grep -q "1 row"; then
      printf "  %-12s ${GREEN}ok${NC}\n" "app_service:"
    else
      printf "  %-12s ${YELLOW}connection issue${NC}\n" "app_service:"
    fi
  else
    printf "  %-12s ${RED}not healthy${NC}\n" "status:"
    all_ok=false
  fi
  echo ""
  
  # Check HTTPS endpoint
  log "https endpoint:"
  if require_cmd curl; then
    local https_test
    https_test=$(curl -sk --connect-timeout 5 -o /dev/null -w "%{http_code}" "https://${EVI_DOMAIN}/" 2>/dev/null || echo "000")
    if [[ "${https_test}" == "200" ]] || [[ "${https_test}" == "301" ]] || [[ "${https_test}" == "302" ]]; then
      printf "  %-12s ${GREEN}ok (HTTP ${https_test})${NC}\n" "status:"
    else
      printf "  %-12s ${YELLOW}issue (HTTP ${https_test})${NC}\n" "status:"
    fi
  else
    printf "  %-12s ${YELLOW}curl not available${NC}\n" "status:"
  fi
  echo ""
  
  # Check TLS certificate
  log "tls certificate:"
  local tls_dir="${ENV_DIR}/tls"
  if [[ "${EVI_TLS_MODE}" == "manual" ]] && [[ -f "${tls_dir}/cert.pem" ]]; then
    local expiry
    expiry=$(openssl x509 -enddate -noout -in "${tls_dir}/cert.pem" 2>/dev/null | cut -d= -f2 || echo "")
    if [[ -n "${expiry}" ]]; then
      local expiry_epoch now_epoch days_left
      expiry_epoch=$(date -d "${expiry}" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "${expiry}" +%s 2>/dev/null || echo "0")
      now_epoch=$(date +%s)
      days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
      
      if [[ ${days_left} -lt 0 ]]; then
        printf "  %-12s ${RED}expired${NC}\n" "status:"
        all_ok=false
      elif [[ ${days_left} -lt 30 ]]; then
        printf "  %-12s ${YELLOW}expiring in ${days_left} days${NC}\n" "status:"
      else
        printf "  %-12s ${GREEN}valid (${days_left} days left)${NC}\n" "status:"
      fi
    fi
  elif [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
    printf "  %-12s ${GREEN}managed by let's encrypt${NC}\n" "mode:"
  else
    printf "  %-12s ${YELLOW}not configured${NC}\n" "status:"
  fi
  echo ""
  
  if [[ "${all_ok}" == true ]]; then
    log "overall: ${GREEN}all systems operational${NC}"
  else
    log "overall: ${YELLOW}some issues detected${NC}"
  fi
}

cmd_cert() {
  local subcmd="${1:-info}"
  shift || true
  
  load_env_files
  local tls_dir="${ENV_DIR}/tls"
  
  case "${subcmd}" in
    info)
      log "== certificate information =="
      if [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
        log "mode: let's encrypt (automatic)"
        log "certificates are managed by caddy and stored in the container volume."
        return 0
      fi
      
      if [[ ! -f "${tls_dir}/cert.pem" ]]; then
        warn "no manual certificates found in ${tls_dir}/"
        return 1
      fi
      
      echo ""
      openssl x509 -in "${tls_dir}/cert.pem" -noout -subject -issuer -dates -ext subjectAltName 2>/dev/null || true
      echo ""
      ;;
    check)
      log "== certificate expiry check =="
      if [[ "${EVI_TLS_MODE}" == "letsencrypt" ]]; then
        log "mode: let's encrypt - certificates auto-renew"
        return 0
      fi
      
      if [[ ! -f "${tls_dir}/cert.pem" ]]; then
        warn "no certificates found"
        return 1
      fi
      
      local expiry
      expiry=$(openssl x509 -enddate -noout -in "${tls_dir}/cert.pem" 2>/dev/null | cut -d= -f2)
      local expiry_epoch now_epoch days_left
      expiry_epoch=$(date -d "${expiry}" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "${expiry}" +%s 2>/dev/null)
      now_epoch=$(date +%s)
      days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
      
      log "expires: ${expiry}"
      log "days left: ${days_left}"
      
      if [[ ${days_left} -lt 30 ]]; then
        warn "certificate expires soon - consider regenerating"
      fi
      ;;
    regen)
      log "== regenerate certificates =="
      if [[ "${EVI_TLS_MODE}" != "manual" ]]; then
        warn "regeneration only applies to manual TLS mode"
        return 1
      fi
      
      require_cmd openssl
      chmod +x "${SCRIPTS_DIR}/gen-self-signed-tls.sh"
      
      log "regenerating certificates for ${EVI_DOMAIN}..."
      "${SCRIPTS_DIR}/gen-self-signed-tls.sh" "${EVI_DOMAIN}" "${tls_dir}" --force
      
      log "certificates regenerated. restart proxy to apply:"
      log "  systemctl --user restart evi-proxy"
      ;;
    install)
      log "== client certificate installation ==="
      if [[ ! -f "${tls_dir}/evi-tls.crt" ]]; then
        warn "CA certificate not found. Generate certificates first."
        return 1
      fi
      
      echo ""
      echo "to eliminate browser warnings, install the CA certificate:"
      echo ""
      echo "certificate file: ${tls_dir}/evi-tls.crt"
      echo ""
      echo "windows: double-click > install > local machine > trusted root ca"
      echo "macos:   double-click > add to keychain > set 'always trust'"
      echo "linux:   sudo cp evi-tls.crt /usr/local/share/ca-certificates/ && sudo update-ca-certificates"
      echo "firefox: settings > privacy > certificates > import > trust for websites"
      echo ""
      ;;
    *)
      echo "usage: evictl cert <info|check|regen|install>"
      ;;
  esac
}

cmd_cleanup() {
  require_cmd podman
  
  log "== cleanup source files =="
  echo ""
  
  # Check deployment status - verify containers are running
  local containers=("evi-db" "evi-be" "evi-fe" "evi-proxy")
  local all_running=true
  
  log "checking deployment status..."
  for c in "${containers[@]}"; do
    local status
    status=$(podman ps --filter "name=^${c}$" --format "{{.Status}}" 2>/dev/null || echo "")
    if [[ -z "${status}" ]]; then
      all_running=false
      break
    fi
  done
  
  if [[ "${all_running}" != "true" ]]; then
    warn "deployment is not running. cleanup is only safe when containers are operational."
    warn "please ensure all services are running before cleanup."
    return 1
  fi
  
  log "deployment is running. proceeding with cleanup check..."
  echo ""
  
  # Define files and directories to remove
  local items_to_remove=(
    "back"
    "front"
    "db"
    "docs"
    "README.md"
    "package.json"
    "package-lock.json"
    ".git"
  )
  
  # Check what actually exists
  local existing_items=()
  for item in "${items_to_remove[@]}"; do
    if [[ -e "${PROJECT_ROOT}/${item}" ]]; then
      existing_items+=("${item}")
    fi
  done
  
  if [[ ${#existing_items[@]} -eq 0 ]]; then
    log "no source files found to clean up."
    return 0
  fi
  
  # Show what will be removed
  log "the following files/directories will be removed:"
  echo ""
  for item in "${existing_items[@]}"; do
    printf "  - %s\n" "${item}"
  done
  echo ""
  warn "this operation is irreversible!"
  echo ""
  
  # Ask for confirmation
  local reply
  read -r -p "do you want to proceed with cleanup? [y/N]: " reply
  if [[ ! "${reply}" =~ ^[Yy]$ ]]; then
    log "cleanup cancelled."
    return 0
  fi
  
  # Perform cleanup
  log "removing source files..."
  local removed_count=0
  local failed_count=0
  
  for item in "${existing_items[@]}"; do
    local item_path="${PROJECT_ROOT}/${item}"
    if [[ -e "${item_path}" ]]; then
      if rm -rf "${item_path}" 2>/dev/null; then
        log "removed: ${item}"
        removed_count=$((removed_count + 1))
      else
        warn "failed to remove: ${item}"
        failed_count=$((failed_count + 1))
      fi
    fi
  done
  
  echo ""
  if [[ ${failed_count} -eq 0 ]]; then
    log "cleanup completed successfully. ${removed_count} item(s) removed."
  else
    warn "cleanup completed with errors. ${removed_count} item(s) removed, ${failed_count} failed."
    return 1
  fi
}

usage() {
  cat <<'EOF'
evictl - evi production deployment controller

Usage:
  evictl <command>
  evictl               # interactive menu

Commands:
  init            Render Quadlet + proxy config, create secrets
  build           Build images from source (using tags defined in env)
  up              Start services
  down            Stop services
  restart         Restart services
  status          Show systemd user unit status
  logs [unit]     Show recent logs (default: evi-proxy)
  update          Pull images and restart
  health          Check health of all services
  cert <subcmd>   Certificate management:
                    info    - Show certificate information
                    check   - Check certificate expiry
                    regen   - Regenerate certificates (manual mode)
                    install - Show client installation instructions
  cleanup         Remove source code files after deployment (back/, front/, db/, docs/, etc.)
  doctor          Validate host prerequisites
  self-update     Update evictl (not implemented yet)
EOF
}

menu() {
  while true; do
    cat <<'EOF'

evi prod manager (evictl)
=========================
1) init
2) build (from source)
3) up
4) down
5) restart
6) status
7) logs (evi-proxy)
8) update (pull)
9) health
10) cert info
11) cleanup
12) doctor
13) exit
EOF
    read -r -p "select option: " choice
    case "${choice}" in
      1) cmd_init ;;
      2) cmd_build ;;
      3) cmd_up ;;
      4) cmd_down ;;
      5) cmd_restart ;;
      6) cmd_status ;;
      7) cmd_logs "evi-proxy" ;;
      8) cmd_update ;;
      9) cmd_health ;;
      10) cmd_cert info ;;
      11) cmd_cleanup ;;
      12) cmd_doctor ;;
      13) exit 0 ;;
      *) warn "invalid option." ;;
    esac
  done
}

main() {
  if [[ "${#}" -eq 0 ]]; then
    menu
    return 0
  fi

  local cmd="$1"; shift || true
  case "${cmd}" in
    init) cmd_init "$@" ;;
    build) cmd_build "$@" ;;
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    restart) cmd_restart "$@" ;;
    status) cmd_status "$@" ;;
    logs) cmd_logs "$@" ;;
    update) cmd_update "$@" ;;
    health) cmd_health "$@" ;;
    cert) cmd_cert "$@" ;;
    cleanup) cmd_cleanup "$@" ;;
    doctor) cmd_doctor "$@" ;;
    self-update) cmd_self_update "$@" ;;
    -h|--help|help) usage ;;
    *) usage; die "Unknown command: ${cmd}" ;;
  esac
}

main "$@"
