# Version: 1.4.0
# Description: Containerfile for evi database container based on official PostgreSQL 18 image with pg_cron support.
# Backend file: Containerfile
# This Containerfile extends the official postgres image and adds initialization scripts.
#
# Changes in v1.1.0:
# - Switched base image to postgres:17 (Debian-based) from postgres:16-alpine
# - Installed pg_cron extension via Debian package and enabled it via shared_preload_libraries
# - Kept automatic execution of maintenance SQL init scripts including pg_cron setup
#
# Changes in v1.1.1:
# - Fixed base image to use full name (docker.io/postgres:17) to resolve Podman short-name resolution issues
#
# Changes in v1.2.0:
# - Added migrations scripts from db/migrations directory (executed after init scripts)
# - Added conditional demo data seeding via environment variable SEED_DEMO_DATA
#
# Changes in v1.2.2:
# - Renamed migration files to m_xxx format in source to ensure correct execution order (m_ > 10_)
# - Renamed demo data target to z_demo_catalog.sql to ensure it runs last (z_ > m_)
# - Removed complex renaming logic from Containerfile as source files are now correctly named
#
# Changes in v1.3.1 (Perms fix):
# - Used COPY --chmod to ensure correct permissions for init scripts (fixes 600 permission issue)
#
# Changes in v1.4.0:
# - Upgraded base image from postgres:17 to postgres:18
# - Updated pg_cron package from postgresql-17-cron to postgresql-18-cron
#
FROM docker.io/postgres:18

# Install pg_cron extension package for PostgreSQL 18
RUN set -eux; \
    apt-get update; \
    apt-get install -y --no-install-recommends \
        postgresql-18-cron; \
    rm -rf /var/lib/apt/lists/*

# Enable pg_cron in the default PostgreSQL configuration
RUN set -eux; \
    echo "shared_preload_libraries = 'pg_cron'" >> /usr/share/postgresql/postgresql.conf.sample; \
    echo "cron.database_name = 'maindb'" >> /usr/share/postgresql/postgresql.conf.sample

# Copy initialization scripts to the entrypoint directory
# These scripts will be executed automatically when the database is first initialized
# Order: init scripts (00-12) -> migrations (m_001 only)
COPY --chmod=644 init/*.sql /docker-entrypoint-initdb.d/
COPY --chmod=755 init/*.sh /docker-entrypoint-initdb.d/

# Copy migration scripts to the entrypoint directory
# Source: only m_001_future_migrations.sql; runs after init scripts (00-12)
# m (109) > 0 (48) and m > 1 (49)
COPY --chmod=644 migrations/*.sql /docker-entrypoint-initdb.d/

# Copy demo data scripts to a SEPARATE directory to prevent automatic execution
# They will be conditionally executed by z_seed-demo-data.sh based on env var
# We use a separate dir because any .sql file in /docker-entrypoint-initdb.d/ runs automatically
COPY --chmod=644 demo-data/*.sql /docker-entrypoint-demo-data/

# Copy wrapper script for conditional execution
# Named z_* to ensure it runs LAST (z > m) after migrations
COPY --chmod=755 docker-entrypoint-initdb.d/seed-demo-data.sh /docker-entrypoint-initdb.d/z_seed-demo-data.sh

# The official postgres image will automatically execute all .sql and .sh files
# in /docker-entrypoint-initdb.d/ in alphabetical order

