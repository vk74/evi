# evi-assets — Object Storage Service

**Version: 1.0.0**  
Backend reference. Service: MinIO S3-compatible object storage running as the `evi-assets` Podman container.

## Overview

`evi-assets` stores all binary files that are not suitable for the relational database:
product media, UI branding assets, and knowledge base documents. It is strictly internal —
only `evi-be` communicates with MinIO over the `evi-network`. The frontend never connects
to MinIO directly using long-lived credentials; all access is mediated through short-lived
**Presigned URLs** generated by `evi-be`.

```
                     evi-network (internal)
┌──────────┐   HTTP S3   ┌─────────────┐
│  evi-be  │ ──────────► │  evi-assets │  port 9000 (S3 API) — internal only
└──────────┘             │   (MinIO)   │  port 9001 → host:9080 (console, UFW-protected)
     ▲                   └─────────────┘
     │ presigned URL
     │
┌──────────┐   direct PUT/GET to presigned URL
│ frontend │ ────────────────────────────────► MinIO (bypasses evi-be transit)
└──────────┘
```

## Bucket Structure

| Bucket | Purpose | Upload TTL | View TTL |
|---|---|---|---|
| `products` | Product card images and photos | 5 min | 5 min |
| `branding` | App logos, custom UI assets | N/A (admin upload) | 24 h (cached in Valkey) |
| `kb-documents` | Knowledge base PDFs and attachments | 5 min | 5 min |

All buckets are **strictly private** — no public read/write policies. Every object access
requires a presigned URL issued by `evi-be`.

### Recommended Object Key Conventions

```
products/{productId}/{uuid}.{ext}        # e.g. products/42/a1b2c3d4.jpg
branding/logo-{tenantId}.{ext}           # e.g. branding/logo-default.svg
kb-documents/{articleId}/{uuid}.{ext}    # e.g. kb-documents/7/a1b2c3d4.pdf
```

## Presigned URLs Pattern

### Why Presigned URLs?

- The SPA is fully closed to external agents. All file requests are authenticated.
- Files can be large (PDFs, high-res images) — routing them through `evi-be` would waste
  memory and saturate the API process needlessly.
- MinIO generates a time-limited signed URL that encodes bucket, key, expiry, and an
  HMAC signature. No credentials are exposed to the browser.

### Upload Flow (PUT)

```
Frontend                    evi-be                      evi-assets (MinIO)
   │                           │                               │
   │  POST /api/assets/        │                               │
   │  upload-url               │                               │
   │  { bucket, filename,      │                               │
   │    contentType }          │                               │
   │ ─────────────────────────►│                               │
   │                           │  PresignedPutObject(          │
   │                           │    bucket, key, 5 min)        │
   │                           │ ─────────────────────────────►│
   │                           │◄─────────────────────────────│
   │                           │  presigned PUT URL            │
   │◄─────────────────────────│                               │
   │  { url, key, expiresAt }  │                               │
   │                           │                               │
   │  PUT <presigned-url>      │                               │
   │  (file bytes, direct)     │                               │
   │ ─────────────────────────────────────────────────────────►│
   │◄─────────────────────────────────────────────────────────│
   │  200 OK                   │                               │
   │                           │                               │
   │  POST /api/products/{id}  │                               │
   │  { imageKey: key }        │                               │  Store key in DB,
   │ ─────────────────────────►│ ─────────────────────────────►│  not the URL
```

**Key point:** `evi-be` stores the object **key** in the database, never the presigned URL
(which is short-lived and will expire).

### View Flow (GET) — products and kb-documents

```
Frontend                    evi-be                      evi-assets (MinIO)
   │                           │                               │
   │  GET /api/assets/         │                               │
   │  view-url?key=products/…  │                               │
   │ ─────────────────────────►│                               │
   │                           │  PresignedGetObject(          │
   │                           │    bucket, key, 5 min)        │
   │                           │ ─────────────────────────────►│
   │                           │◄─────────────────────────────│
   │◄─────────────────────────│                               │
   │  { url, expiresAt }       │                               │
   │                           │                               │
   │  GET <presigned-url>      │                               │
   │  (direct, no BE transit)  │                               │
   │ ─────────────────────────────────────────────────────────►│
   │◄─────────────────────────────────────────────────────────│
   │  file bytes               │                               │
```

The frontend should treat the returned URL as single-use / short-lived. Do not cache it
across page navigations or sessions. Re-request from `evi-be` when needed.

### Branding Flow (GET) — logos and UI assets

Logos change rarely. Generating a new presigned URL on every page render is wasteful.
`evi-be` caches presigned GET URLs in Valkey with a 24-hour TTL. The URL is regenerated
automatically when the cache entry expires or when a new logo is uploaded.

```
Frontend                    evi-be              evi-state (Valkey)    evi-assets (MinIO)
   │                           │                       │                      │
   │  GET /api/assets/         │                       │                      │
   │  branding/logo            │                       │                      │
   │ ─────────────────────────►│                       │                      │
   │                           │  GET branding:logo    │                      │
   │                           │ ─────────────────────►│                      │
   │                           │                       │                      │
   │         ┌─────────────────┤ cache hit             │                      │
   │         │  cached URL     │◄──────────────────────│                      │
   │         │                 │                       │                      │
   │         │ cache miss      │  PresignedGetObject(  │                      │
   │         │                 │  bucket, key, 24h)    │                      │
   │         │                 │ ─────────────────────────────────────────────►│
   │         │                 │◄─────────────────────────────────────────────│
   │         │                 │  SET branding:logo    │                      │
   │         │                 │  EX 82800 (23 h)      │                      │
   │         │                 │ ─────────────────────►│                      │
   │         └────────────────►│                       │                      │
   │◄─────────────────────────│                       │                      │
   │  { url }                  │                       │                      │
   │                           │                       │                      │
   │  GET <presigned-url>                                                      │
   │ ──────────────────────────────────────────────────────────────────────── ►│
   │◄──────────────────────────────────────────────────────────────────────── │
```

**Valkey key format:** `branding:{assetName}` (e.g. `branding:logo-default`)  
**Valkey TTL:** 82800 seconds (23 hours — 1 hour safety margin before MinIO URL expiry at 24 h)

When a user uploads a new logo via the admin panel, `evi-be` must **invalidate** the
corresponding Valkey key so the next request gets a fresh URL pointing to the new file:

```typescript
// After storing new logo key in DB
await valkey.del(`branding:${assetName}`)
```

## Connecting from evi-be

MinIO is reachable inside `evi-network` at `http://evi-assets:9000`.

### Recommended SDK

Use the official [MinIO JavaScript SDK](https://github.com/minio/minio-js) (`minio` npm package).

```typescript
import * as Minio from 'minio'

const minioClient = new Minio.Client({
  endPoint: 'evi-assets',
  port: 9000,
  useSSL: false,
  accessKey: process.env.MINIO_ROOT_USER,   // from EVI_ASSETS_ROOT_USER via env
  secretKey: process.env.MINIO_ROOT_PASSWORD,
})
```

For production `evi-be`, inject `MINIO_ROOT_USER` and `MINIO_ROOT_PASSWORD` as environment
variables — they are already rendered into the `evi-assets.container` Quadlet from
`evi.secrets.env`. Add corresponding `Environment=` lines to `evi-be.container` as well,
or use a dedicated service-account key created via the MinIO console (recommended for
least-privilege: service account cannot access the management console).

### Generating Presigned URLs

```typescript
// Presigned PUT — upload (5 minutes)
const uploadUrl = await minioClient.presignedPutObject(
  'products',             // bucket
  `products/${productId}/${uuid}.jpg`,  // key
  5 * 60,                 // TTL in seconds
)

// Presigned GET — view (5 minutes)
const viewUrl = await minioClient.presignedGetObject(
  'products',
  `products/${productId}/${uuid}.jpg`,
  5 * 60,
)

// Presigned GET — branding (24 hours, cached in Valkey by caller)
const logoUrl = await minioClient.presignedGetObject(
  'branding',
  'logo-default.svg',
  24 * 60 * 60,
)
```

## Initial Bucket Setup

After first deploy, create the required buckets via the MinIO console
(`http://<host>:9080`) or with the MinIO Client (`mc`):

```bash
# Using mc from the host (after mc alias add)
mc alias set evi http://localhost:9000 <EVI_ASSETS_ROOT_USER> <EVI_ASSETS_ROOT_PASSWORD>
mc mb evi/products
mc mb evi/branding
mc mb evi/kb-documents
# All buckets remain private (no public policy)
```

Bucket creation can be automated as part of a future `evi-be` startup initialisation step.

## Management Console

The MinIO management console is available at `http://<host>:9080`.
Access is restricted by the same UFW firewall rules as cockpit and pgAdmin
(`EVI_FIREWALL_ADMIN_ACCESS` / `EVI_FIREWALL_ADMIN_ALLOWED` in `evi.env`).

Credentials are set via `EVI_ASSETS_ROOT_USER` and `EVI_ASSETS_ROOT_PASSWORD` in
`evi.secrets.env`.

> **Tip:** For day-to-day backend use, create a **service account** in the MinIO console
> (Identity → Service Accounts) with a scoped policy limited to the required buckets.
> Store the generated access/secret key pair in `evi.secrets.env` and use those in
> `evi-be` instead of the root credentials. This follows the principle of least privilege.
